<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"misakatang.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"style":null,"show_result":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="The limits of my language are the limits of my world">
<meta property="og:type" content="website">
<meta property="og:title" content="MisakaTang&#39;s Blog">
<meta property="og:url" content="http://misakatang.cn/page/16/index.html">
<meta property="og:site_name" content="MisakaTang&#39;s Blog">
<meta property="og:description" content="The limits of my language are the limits of my world">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="MisakaTang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://misakatang.cn/page/16/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/16/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MisakaTang's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4TSLH4NC9H"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-4TSLH4NC9H","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?de7c77febeeac252eee468207ae11ce4"></script>



  <script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "jtb4czrfeu");
</script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="MisakaTang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">MisakaTang's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MisakaTang"
      src="/images/misaka.jpg">
  <p class="site-author-name" itemprop="name">MisakaTang</p>
  <div class="site-description" itemprop="description">The limits of my language are the limits of my world</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/%E5%BD%92%E6%A1%A3/">
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/TangMisaka23001" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TangMisaka23001" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mikasatang@gmail.com" title="E-Mail → mailto:mikasatang@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="http://blog.bbchen.top/" title="http:&#x2F;&#x2F;blog.bbchen.top" rel="noopener" target="_blank">BB chen的漂流记</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://blog.zhuzhenyuan.cn/" title="http:&#x2F;&#x2F;blog.zhuzhenyuan.cn" rel="noopener" target="_blank">Aurthur_的博客</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://misakatang.cn/2019/03/02/%E9%98%BF%E9%87%8C%E4%BA%91RDS%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%E4%B8%BB%E4%BB%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/misaka.jpg">
      <meta itemprop="name" content="MisakaTang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MisakaTang's Blog">
      <meta itemprop="description" content="The limits of my language are the limits of my world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | MisakaTang's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/02/%E9%98%BF%E9%87%8C%E4%BA%91RDS%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%E4%B8%BB%E4%BB%8E/" class="post-title-link" itemprop="url">阿里云RDS逻辑备份恢复主从</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-02 15:59:20" itemprop="dateCreated datePublished" datetime="2019-03-02T15:59:20+00:00">2019-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-14 08:33:24" itemprop="dateModified" datetime="2024-03-14T08:33:24+00:00">2024-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h1><p>在主从备份恢复没多久之后,从库又出现了新的错误:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">The manual page at http://dev.mysql.com/doc/mysql/en/crashing.html contains</span><br><span class="line">information that should help you find out what is causing the crash.</span><br><span class="line">190220 00:00:01 mysqld_safe Number of processes running now: 0</span><br><span class="line">190220 00:00:01 mysqld_safe mysqld restarted</span><br><span class="line">2019-02-20 00:00:02 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).</span><br><span class="line">2019-02-20 00:00:02 0 [Note] /usr/sbin/mysqld (mysqld 5.6.39-log) starting as process 31815 ...</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] Plugin &#x27;FEDERATED&#x27; is disabled.</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Using atomics to ref count buffer pool pages</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: The InnoDB memory heap is disabled</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Memory barrier is not used</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Compressed tables use zlib 1.2.3</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Using Linux native AIO</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Using CPU crc32 instructions</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Initializing buffer pool, size = 128.0M</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Completed initialization of buffer pool</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Highest supported file format is Barracuda.</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Log scan progressed past the checkpoint lsn 17886034157</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Database was not shutdown normally!</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Starting crash recovery.</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Reading tablespace information from the .ibd files...</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Restoring possible half-written data pages </span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: from the doublewrite buffer...</span><br><span class="line">InnoDB: Doing recovery: scanned up to log sequence number 17886040149</span><br><span class="line">InnoDB: Last MySQL binlog file position 0 5052574, file name mysql-bin.000002</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: 128 rollback segment(s) are active.</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: Waiting for purge to start</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] InnoDB: 5.6.39 started; log sequence number 17886040149</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] Recovering after a crash using /data/log/mysql/mysql-bin</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] Starting crash recovery...</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] Crash recovery finished.</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] Server hostname (bind-address): &#x27;*&#x27;; port: 3306</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] IPv6 is available.</span><br><span class="line">2019-02-20 00:00:02 31815 [Note]   - &#x27;::&#x27; resolves to &#x27;::&#x27;;</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] Server socket created on IP: &#x27;::&#x27;.</span><br><span class="line">2019-02-20 00:00:02 31815 [Warning] &#x27;user&#x27; entry &#x27;root@izbp127nd1c1ngjebt90o3z&#x27; ignored in --skip-name-resolve mode.</span><br><span class="line">2019-02-20 00:00:02 31815 [Warning] &#x27;user&#x27; entry &#x27;@izbp127nd1c1ngjebt90o3z&#x27; ignored in --skip-name-resolve mode.</span><br><span class="line">2019-02-20 00:00:02 31815 [Warning] &#x27;proxies_priv&#x27; entry &#x27;@ root@izbp127nd1c1ngjebt90o3z&#x27; ignored in --skip-name-resolve mode.</span><br><span class="line">2019-02-20 00:00:02 31815 [Warning] Neither --relay-log nor --relay-log-index were used; so replication may break when this MySQL server acts as a slave and has his hostname changed!! Please use &#x27;--relay-log=mysqld-relay-bin&#x27; to avoid this problem.</span><br><span class="line">2019-02-20 00:00:02 31815 [Warning] Storing MySQL user name or password information in the master info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START SLAVE; see the &#x27;START SLAVE Syntax&#x27;</span><br><span class="line"> in the MySQL Manual for more information.</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] Slave I/O thread: connected to master &#x27;slave-001-read@rm-bp16vmecn3tzzl51u.mysql.rds.aliyuncs.com:3306&#x27;,replication started in log &#x27;mysql-bin.001423&#x27; at position 4492905</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] Event Scheduler: Loaded 0 events</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] /usr/sbin/mysqld: ready for connections.</span><br><span class="line">Version: &#x27;5.6.39-log&#x27;  socket: &#x27;/data/mysql/mysql.sock&#x27;  port: 3306  MySQL Community Server (GPL)</span><br><span class="line">2019-02-20 00:00:02 31815 [Warning] Slave SQL: If a crash happens this configuration does not guarantee that the relay log info will be consistent, Error_code: 0</span><br><span class="line">2019-02-20 00:00:02 31815 [Note] Slave SQL thread initialized, starting replication in log &#x27;mysql-bin.001422&#x27; at position 1778562, relay log &#x27;./mysqld-relay-bin.000006&#x27; position: 1778732</span><br><span class="line">2019-02-20 00:00:02 7f3b7850e700  InnoDB: Assertion failure in thread 139893398365952 in file pars0pars.cc line 865</span><br><span class="line">InnoDB: Failing assertion: sym_node-&gt;table != NULL</span><br><span class="line">InnoDB: We intentionally generate a memory trap.</span><br><span class="line">InnoDB: Submit a detailed bug report to http://bugs.mysql.com.</span><br><span class="line">InnoDB: If you get repeated assertion failures or crashes, even</span><br><span class="line">InnoDB: immediately after the mysqld startup, there may be</span><br><span class="line">InnoDB: corruption in the InnoDB tablespace. Please refer to</span><br><span class="line">InnoDB: http://dev.mysql.com/doc/refman/5.6/en/forcing-innodb-recovery.html</span><br><span class="line">InnoDB: about forcing recovery.</span><br><span class="line">16:00:02 UTC - mysqld got signal 6 ;</span><br><span class="line">This could be because you hit a bug. It is also possible that this binary</span><br><span class="line">or one of the libraries it was linked against is corrupt, improperly built,</span><br><span class="line">or misconfigured. This error can also be caused by malfunctioning hardware.</span><br><span class="line">We will try our best to scrape up some info that will hopefully help</span><br><span class="line">diagnose the problem, but since we have already crashed, </span><br><span class="line">something is definitely wrong and this may fail.</span><br><span class="line"></span><br><span class="line">key_buffer_size=8388608</span><br><span class="line">read_buffer_size=131072</span><br><span class="line">max_used_connections=0</span><br><span class="line">max_threads=2000</span><br><span class="line">thread_count=2</span><br><span class="line">connection_count=0</span><br><span class="line">It is possible that mysqld could use up to </span><br><span class="line">key_buffer_size + (read_buffer_size + sort_buffer_size)*max_threads = 801785 K  bytes of memory</span><br><span class="line">Hope that&#x27;s ok; if not, decrease some variables in the equation.</span><br><span class="line"></span><br><span class="line">Thread pointer: 0x7f3b48000990</span><br><span class="line">Attempting backtrace. You can use the following information to find out</span><br><span class="line">where mysqld died. If you see no messages after this, something went</span><br><span class="line">terribly wrong...</span><br><span class="line">stack_bottom = 7f3b7850d9d0 thread_stack 0x40000</span><br><span class="line">/usr/sbin/mysqld(my_print_stacktrace+0x3b)[0x8e986b]</span><br><span class="line">/usr/sbin/mysqld(handle_fatal_signal+0x491)[0x675b01]</span><br><span class="line">/lib64/libpthread.so.0(+0xf5e0)[0x7f3bb5b895e0]</span><br><span class="line">/lib64/libc.so.6(gsignal+0x37)[0x7f3bb47831f7]</span><br><span class="line">/lib64/libc.so.6(abort+0x148)[0x7f3bb47848e8]</span><br><span class="line">/usr/sbin/mysqld[0x988ce7]</span><br><span class="line">/usr/sbin/mysqld(_Z7yyparsev+0x1e7f)[0xabecdf]</span><br><span class="line">/usr/sbin/mysqld[0x98af81]</span><br><span class="line">/usr/sbin/mysqld[0xaba9f8]</span><br><span class="line">/usr/sbin/mysqld[0xaa0786]</span><br><span class="line">/usr/sbin/mysqld[0xaad730]</span><br><span class="line">/usr/sbin/mysqld[0xaad985]</span><br><span class="line">/usr/sbin/mysqld[0xaadf10]</span><br><span class="line">/usr/sbin/mysqld[0x9b1d78]</span><br><span class="line">/usr/sbin/mysqld[0x921478]</span><br><span class="line">/usr/sbin/mysqld(_ZN7handler12ha_write_rowEPh+0xaa)[0x5bdbfa]</span><br><span class="line">/usr/sbin/mysqld(_ZN20Write_rows_log_event9write_rowEPK14Relay_log_infob+0x135)[0x8804d5]</span><br><span class="line">/usr/sbin/mysqld(_ZN20Write_rows_log_event11do_exec_rowEPK14Relay_log_info+0x19)[0x8807f9]</span><br><span class="line">/usr/sbin/mysqld(_ZN14Rows_log_event12do_apply_rowEPK14Relay_log_info+0x26)[0x870586]</span><br><span class="line">/usr/sbin/mysqld(_ZN14Rows_log_event14do_apply_eventEPK14Relay_log_info+0x566)[0x87e616]</span><br><span class="line">/usr/sbin/mysqld(_ZN9Log_event11apply_eventEP14Relay_log_info+0x6a)[0x877dfa]</span><br><span class="line">/usr/sbin/mysqld(_Z26apply_event_and_update_posPP9Log_eventP3THDP14Relay_log_info+0x258)[0x8affa8]</span><br><span class="line">/usr/sbin/mysqld(handle_slave_sql+0x17ce)[0x8b3dde]</span><br><span class="line">/usr/sbin/mysqld(pfs_spawn_thread+0x146)[0xb417a6]</span><br><span class="line">/lib64/libpthread.so.0(+0x7e25)[0x7f3bb5b81e25]</span><br><span class="line">/lib64/libc.so.6(clone+0x6d)[0x7f3bb484634d]</span><br><span class="line"></span><br><span class="line">Trying to get some variables.</span><br><span class="line">Some pointers may be invalid and cause the dump to abort.</span><br><span class="line">Query (0): Connection ID (thread ID): 2</span><br><span class="line">Status: NOT_KILLED</span><br></pre></td></tr></table></figure>

<p>并且大量出现了这个错误日志,同时MySQL的目录下relay_log大量堆积.并且服务器一直处于无法正常启动的情况下,在参考了<a target="_blank" rel="noopener" href="https://m.fuwuqizhijia.com/mysql/201704/33120.html">mysql的killed mysql数据启动大量报错且无法启动故障排查</a>之后,使用下面的方法正常启动的MySQL的进程:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span>mysql<span class="operator">/</span>bin<span class="operator">/</span>mysqld_safe <span class="comment">--relay-log nor --relay-log-index</span></span><br></pre></td></tr></table></figure>
<p>个人估计原因是由于主从同步一直失败导致MySQL目录下relay_log堆积过多导致的,思路来自这个错误信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-02-20 00:00:02 31815 [Warning] Neither --relay-log nor --relay-log-index were used; so replication may break when this MySQL server acts as a slave and has his hostname changed!! Please use &#x27;--relay-log=mysqld-relay-bin&#x27; to avoid this problem.</span><br></pre></td></tr></table></figure>
<p>启动成功之后执行下面的命令:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset slave <span class="keyword">all</span>;</span><br></pre></td></tr></table></figure>
<p>并且清空了relay_log之后就可以正常启动MySQL的服务了.</p>
<h1 id="尝试恢复主从"><a href="#尝试恢复主从" class="headerlink" title="尝试恢复主从"></a>尝试恢复主从</h1><p>在经历了上一次的折腾之后,本以为可以轻松恢复主从同步,没想到还是踩了很多的坑.</p>
<h2 id="基于逻辑备份"><a href="#基于逻辑备份" class="headerlink" title="基于逻辑备份"></a>基于逻辑备份</h2><p>使用上次基于物理备份恢复单库的时候出现了致命的问题,数据恢复之后指定了对应的GTID,但是relay_log的位置并没有和主库对齐导致数据无法继续同步.于是换用了逻辑备份的方式,再次之前查看了GTID相关的内容.</p>
<h2 id="GITD"><a href="#GITD" class="headerlink" title="GITD"></a>GITD</h2><blockquote>
<p><strong>什么是GTID</strong></p>
<p>GTID (Global Transaction ID) 是对于一个已提交事务的编号，并且是一个全局唯一的编号。 GTID 实际上 是由 UUID+TID 组成的。其中 UUID 是一个 MySQL 实例的唯一标识。TID 代表了该实例上已经提交的事务数量，并且随着事务提交单调递增。</p>
</blockquote>
<blockquote>
<p><strong>什么是GTID Replication</strong></p>
<p>从 MySQL 5.6.5 开始新增了一种基于 GTID 的复制方式。通过 GTID 保证了每个在主库上提交的事务在集群中有一个唯一的ID。这种方式强化了数据库的主备一致性，故障恢复以及容错能力。</p>
<p>在原来基于二进制日志的复制中，从库需要告知主库要从哪个偏移量进行增量同步，如果指定错误会造成数据的遗漏，从而造成数据的不一致。借助GTID，在发生主备切换的情况下，MySQL的其它从库可以自动在新主库上找到正确的复制位置，这大大简化了复杂复制拓扑下集群的维护，也减少了人为设置复制位置发生误操作的风险。另外，基于GTID的复制可以忽略已经执行过的事务，减少了数据发生不一致的风险。</p>
</blockquote>
<h1 id="进行主从同步"><a href="#进行主从同步" class="headerlink" title="进行主从同步"></a>进行主从同步</h1><p>在查看了阿里云RDS下载的逻辑备份数据sql之后发现其中已经包括了GTID相关的设置:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@MYSQLDUMP_TEMP_LOG_BIN</span> <span class="operator">=</span> @<span class="variable">@SESSION</span>.SQL_LOG_BIN;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.SQL_LOG_BIN<span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@GLOBAL</span>.GTID_PURGED<span class="operator">=</span><span class="string">&#x27;GTID_PURGED的值&#x27;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.SQL_LOG_BIN <span class="operator">=</span> <span class="variable">@MYSQLDUMP_TEMP_LOG_BIN</span>;</span><br></pre></td></tr></table></figure>
<p>所以进行数据备份和开启主从同步就变得更加简单了,只需要在导入sql之前</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure>
<p>保证sql中的GTID能够正确设置就可以了~</p>
<p>没有reset会产生的错误如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1840 (HY000) at line 24: @@GLOBAL.GTID_PURGED can only be set when @@GLOBAL.GTID_EXECUTED is empty.</span><br></pre></td></tr></table></figure>
<p>如此一来,只需要导入dump.sql然后设置主从同步,整个过程就ok了!</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;host&#x27;</span>, MASTER_USER<span class="operator">=</span><span class="string">&#x27;user&#x27;</span>, MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;passwd&#x27;</span>, MASTER_AUTO_POSITION <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在过程中还遇到了下面的错误:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">: Error: </span><br><span class="line">Table &quot;mysql&quot;.&quot;innodb_table_stats&quot;</span><br><span class="line"> not found. InnoDB: Recalculation </span><br><span class="line">of persistent statistics requested for table &quot;mydatabase&quot;.&quot;mytable&quot; </span><br><span class="line">but the required persistent statistics storage is not present or is corrupted. </span><br><span class="line">Using transient stats instead.</span><br></pre></td></tr></table></figure>
<p>检查之后发现mysql库文件中的<strong>innodb_index_stats</strong>,<strong>innodb_table_stats</strong>,<strong>slave_master_info</strong>,<strong>slave_relay_log_info</strong>,<strong>slave_worker_info</strong>全部都损坏了,解决方法是删除这5张表然后进行重建,建表sql如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `innodb_index_stats` (</span><br><span class="line">  `database_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `table_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `index_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `last_update` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `stat_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `stat_value` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sample_size` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `stat_description` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`database_name`,`table_name`,`index_name`,`stat_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin STATS_PERSISTENT<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `innodb_table_stats` (</span><br><span class="line">  `database_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `table_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `last_update` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `n_rows` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `clustered_index_size` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sum_of_other_index_sizes` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`database_name`,`table_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin STATS_PERSISTENT<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `slave_master_info` (</span><br><span class="line">  `Number_of_lines` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Number of lines in the file.&#x27;</span>,</span><br><span class="line">  `Master_log_name` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;The name of the master binary log currently being read from the master.&#x27;</span>,</span><br><span class="line">  `Master_log_pos` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;The master log position of the last read event.&#x27;</span>,</span><br><span class="line">  `Host` <span class="type">char</span>(<span class="number">64</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;The host name of the master.&#x27;</span>,</span><br><span class="line">  `User_name` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;The user name used to connect to the master.&#x27;</span>,</span><br><span class="line">  `User_password` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;The password used to connect to the master.&#x27;</span>,</span><br><span class="line">  `Port` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;The network port used to connect to the master.&#x27;</span>,</span><br><span class="line">  `Connect_retry` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;The period (in seconds) that the slave will wait before trying to reconnect to the master.&#x27;</span>,</span><br><span class="line">  `Enabled_ssl` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Indicates whether the server supports SSL connections.&#x27;</span>,</span><br><span class="line">  `Ssl_ca` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;The file used for the Certificate Authority (CA) certificate.&#x27;</span>,</span><br><span class="line">  `Ssl_capath` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;The path to the Certificate Authority (CA) certificates.&#x27;</span>,</span><br><span class="line">  `Ssl_cert` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;The name of the SSL certificate file.&#x27;</span>,</span><br><span class="line">  `Ssl_cipher` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;The name of the cipher in use for the SSL connection.&#x27;</span>,</span><br><span class="line">  `Ssl_key` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;The name of the SSL key file.&#x27;</span>,</span><br><span class="line">  `Ssl_verify_server_cert` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Whether to verify the server certificate.&#x27;</span>,</span><br><span class="line">  `Heartbeat` <span class="type">float</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Bind` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;Displays which interface is employed when connecting to the MySQL server&#x27;</span>,</span><br><span class="line">  `Ignored_server_ids` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;The number of server IDs to be ignored, followed by the actual server IDs&#x27;</span>,</span><br><span class="line">  `Uuid` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;The master server uuid.&#x27;</span>,</span><br><span class="line">  `Retry_count` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Number of reconnect attempts, to the master, before giving up.&#x27;</span>,</span><br><span class="line">  `Ssl_crl` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;The file used for the Certificate Revocation List (CRL)&#x27;</span>,</span><br><span class="line">  `Ssl_crlpath` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;The path used for Certificate Revocation List (CRL) files&#x27;</span>,</span><br><span class="line">  `Enabled_auto_position` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Indicates whether GTIDs will be used to retrieve events from the master.&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`Host`,`Port`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 STATS_PERSISTENT<span class="operator">=</span><span class="number">0</span> COMMENT<span class="operator">=</span><span class="string">&#x27;Master Information&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `slave_relay_log_info` (</span><br><span class="line">  `Number_of_lines` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Number of lines in the file or rows in the table. Used to version table definitions.&#x27;</span>,</span><br><span class="line">  `Relay_log_name` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;The name of the current relay log file.&#x27;</span>,</span><br><span class="line">  `Relay_log_pos` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;The relay log position of the last executed event.&#x27;</span>,</span><br><span class="line">  `Master_log_name` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;The name of the master binary log file from which the events in the relay log file were read.&#x27;</span>,</span><br><span class="line">  `Master_log_pos` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;The master log position of the last executed event.&#x27;</span>,</span><br><span class="line">  `Sql_delay` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;The number of seconds that the slave must lag behind the master.&#x27;</span>,</span><br><span class="line">  `Number_of_workers` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Internal Id that uniquely identifies this record.&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`Id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 STATS_PERSISTENT<span class="operator">=</span><span class="number">0</span> COMMENT<span class="operator">=</span><span class="string">&#x27;Relay Log Information&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `slave_worker_info` (</span><br><span class="line">  `Id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Relay_log_name` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Relay_log_pos` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Master_log_name` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Master_log_pos` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Checkpoint_relay_log_name` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Checkpoint_relay_log_pos` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Checkpoint_master_log_name` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Checkpoint_master_log_pos` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Checkpoint_seqno` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Checkpoint_group_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `Checkpoint_group_bitmap` <span class="type">blob</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`Id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 STATS_PERSISTENT<span class="operator">=</span><span class="number">0</span> COMMENT<span class="operator">=</span><span class="string">&#x27;Worker Information&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>之后主从同步恢复正常~</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://www.hi-linux.com/posts/47176.html#%E6%B5%8B%E8%AF%95gtid%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">MySQL 5.7 基于 GTID 的主从复制实践</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/15767652/mysql-error-table-mysql-innodb-table-stats-not-found">StackOverflow:mysql error: Table “mysql”.“innodb_table_stats” not found</a></p>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/knowledge_detail/97438.html">RDS for MySQL 逻辑备份文件恢复到自建数据库</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://misakatang.cn/2019/03/01/InnoDB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-14.6%20InnoDB%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E7%9A%84%E7%BB%93%E6%9E%84-14.6.1%20%E8%A1%A8(Tables)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/misaka.jpg">
      <meta itemprop="name" content="MisakaTang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MisakaTang's Blog">
      <meta itemprop="description" content="The limits of my language are the limits of my world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | MisakaTang's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/01/InnoDB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-14.6%20InnoDB%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E7%9A%84%E7%BB%93%E6%9E%84-14.6.1%20%E8%A1%A8(Tables)/" class="post-title-link" itemprop="url">InnoDB官方文档--14.6 InnoDB在磁盘上的结构--14.6.1表(Tables)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-01 17:22:22" itemprop="dateCreated datePublished" datetime="2019-03-01T17:22:22+00:00">2019-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-14 08:33:24" itemprop="dateModified" datetime="2024-03-14T08:33:24+00:00">2024-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="14-6-InnoDB在磁盘上的结构-InnoDB-On-Disk-Structures"><a href="#14-6-InnoDB在磁盘上的结构-InnoDB-On-Disk-Structures" class="headerlink" title="14.6 InnoDB在磁盘上的结构(InnoDB On-Disk Structures)"></a>14.6 InnoDB在磁盘上的结构(InnoDB On-Disk Structures)</h3><h4 id="14-6-1-表-Tables"><a href="#14-6-1-表-Tables" class="headerlink" title="14.6.1 表(Tables)"></a>14.6.1 表(Tables)</h4><h5 id="14-6-1-1-创建InnoDB表"><a href="#14-6-1-1-创建InnoDB表" class="headerlink" title="14.6.1.1 创建InnoDB表"></a>14.6.1.1 创建InnoDB表</h5><p>使用<code>CREATE TABLE</code>语句来创建一个InnoDB表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (a <span class="type">INT</span>, b <span class="type">CHAR</span> (<span class="number">20</span>), <span class="keyword">PRIMARY</span> KEY (a)) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>如果InnoDB是默认的存储引擎的话你不需要特定指定<code>ENGINE=InnoDB</code>,可以使用下面语句检查默认的存储引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@default_storage_engine</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@default_storage_engine</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="operator">|</span> InnoDB                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br></pre></td></tr></table></figure>


<p>如果你计划使用<strong>mysqldump</strong>或Replication在一个默认存储引擎不是InnoDB的服务器上重用<code>CREATE TABLE</code>语句时仍旧可以使用<code>ENGINE=InnoDB</code>子句.</p>
<p>InnoDB表和它的索引被创建在系统表空间(system tablespace),单表单文件(file-per-table)表空间或通用表空间( general tablespace)中.当<em>innodb_file_per_table</em>启用的时候,默认情况下,InnoDB表会被隐式的创建在一个单独的单表单文件表空间中.相反的,当<em>innodb_file_per_table</em>禁用的时候,InnoDB表会被隐式的创建在系统表空间中.使用<code>CREATE TABLE ... TABLESPACE</code>可以在通用表空间中创建表.</p>
<p>当你创建InnoDB表的时候,MySQL会创建一个**.frm<strong>文件在MySQL数据文件的数据库目录下.对于创建在单表单文件表空间中的表,MySQL也会默认创建一个</strong>.ibd<strong>表空间文件在数据库目录下.在InnoDB的系统表空间中创建的表被创建在一个已经存在的</strong>ibdata<strong>文件中,该文件保存在MySQL的数据目录下.在通用表空间中创建的表被创建在已存在的</strong>.ibd**文件中.通用表空间文件可以被创建在MySQL数据目录内或之外.</p>
<p>在内部,InnoDB在InnoDB数据字典里为每一张表增加一个目录.这个目录包括了数据库名.例如,在<code>test</code>数据库里创建<code>t1</code>表,数据目录的名字就是<code>test/t1</code>.这意味着你可以在不同的数据库里创建一个同名的表并且在InnoDB里不会冲突.</p>
<p><strong>InnoDB表和.frm文件</strong></p>
<p>InnoDB表默认的行格式(row format)由<code>innodb_default_row_format</code>来定义,默认值为DYNAMIC.Dynamic和Compressed行格式允许你使用InnoDB特性例如表压缩和有效的长列值的页外存储.要使用行格式,<code>innodb_file_per_table</code>必须要启用并且<code>innodb_file_format</code>必须设置为<strong>Barracuda</strong>.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_file_per_table<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_file_format<span class="operator">=</span>barracuda;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (a <span class="type">INT</span>, b <span class="type">CHAR</span> (<span class="number">20</span>), <span class="keyword">PRIMARY</span> KEY (a)) ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t4 (a <span class="type">INT</span>, b <span class="type">CHAR</span> (<span class="number">20</span>), <span class="keyword">PRIMARY</span> KEY (a)) ROW_FORMAT<span class="operator">=</span>COMPRESSED;</span><br></pre></td></tr></table></figure>

<p>另外,你可以使用<code>CREATE TABLE ... TABLESPACE</code>语句在通用表空间中创建InnoDB表.通用表空间支持全部行格式.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY) TABLESPACE ts1 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span>;</span><br></pre></td></tr></table></figure>

<p><code>CREATE TABLE ... TABLESPACE</code>也可以被用来在系统表空间里创建一个行格式为Dynamic以及Compact或Redundant的InnoDB表.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY) TABLESPACE <span class="operator">=</span> innodb_system ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span>;</span><br></pre></td></tr></table></figure>

<p><strong>InnoDB表和主键(Primary Keys)</strong></p>
<p>总是为InnoDB表指定主键,指定下面的一列或多列:</p>
<ul>
<li>被最重要的查询引用</li>
<li>永远不为空</li>
<li>永远不会有重复值</li>
<li>在插入之后很少改变</li>
</ul>
<p>例如,在一张包含人员信息的表里,你不会在(firstname, lastname)上创建主键,因为不止一个人可以有相同的名字,一些人last name是空的,一些人会改名.在这么多的约束下,通常不会有很明显的列来做主键,所以你创建了一个新的列叫数字ID作为主键或者主键的一部分.你可以声明一个自增(auto-increment)列使得在插入行的时候自增.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># The <span class="keyword">value</span> <span class="keyword">of</span> ID can act <span class="keyword">like</span> a pointer <span class="keyword">between</span> related items <span class="keyword">in</span> different tables.</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t5 (id <span class="type">INT</span> AUTO_INCREMENT, b <span class="type">CHAR</span> (<span class="number">20</span>), <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"></span><br><span class="line"># The <span class="keyword">primary</span> key can consist <span class="keyword">of</span> more than <span class="keyword">one</span> column. <span class="keyword">Any</span> autoinc <span class="keyword">column</span> must come first.</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t6 (id <span class="type">INT</span> AUTO_INCREMENT, a <span class="type">INT</span>, b <span class="type">CHAR</span> (<span class="number">20</span>), <span class="keyword">PRIMARY</span> KEY (id,a));</span><br></pre></td></tr></table></figure>

<p>虽然表可以在没有定义主键的情况下工作,但是主键涉及到性能的许多方面并且是任何大型或者经常使用的表的关键的设计方面.建议在<code>CREATE TABLE</code>语句中就指定主键.如果你创建表,加载数据后使用<code>ALTER TABLE</code>来添加一个主键会比创建表时定义主键慢得多.</p>
<p><strong>查看InnoDB表属性</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">FROM</span> test <span class="keyword">LIKE</span> <span class="string">&#x27;t%&#x27;</span> \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: t1</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: <span class="number">10</span></span><br><span class="line">     Row_format: Compact</span><br><span class="line">           <span class="keyword">Rows</span>: <span class="number">0</span></span><br><span class="line"> Avg_row_length: <span class="number">0</span></span><br><span class="line">    Data_length: <span class="number">16384</span></span><br><span class="line">Max_data_length: <span class="number">0</span></span><br><span class="line">   Index_length: <span class="number">0</span></span><br><span class="line">      Data_free: <span class="number">0</span></span><br><span class="line"> Auto_increment: <span class="keyword">NULL</span></span><br><span class="line">    Create_time: <span class="number">2015</span><span class="number">-03</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">13</span>:<span class="number">31</span></span><br><span class="line">    Update_time: <span class="keyword">NULL</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: latin1_swedish_ci</span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options:</span><br><span class="line">        Comment:</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>InnoDB表的属性也可以使用<code>INFORMATION_SCHEMA</code>表来查看:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;test/t1&#x27;</span> \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">     TABLE_ID: <span class="number">45</span></span><br><span class="line">         NAME: test<span class="operator">/</span>t1</span><br><span class="line">         FLAG: <span class="number">1</span></span><br><span class="line">       N_COLS: <span class="number">5</span></span><br><span class="line">        SPACE: <span class="number">35</span></span><br><span class="line">  FILE_FORMAT: Antelope</span><br><span class="line">   ROW_FORMAT: Compact</span><br><span class="line">ZIP_PAGE_SIZE: <span class="number">0</span></span><br><span class="line">   SPACE_TYPE: Single</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h5 id="14-6-1-2-移动或复制InnoDB表"><a href="#14-6-1-2-移动或复制InnoDB表" class="headerlink" title="14.6.1.2 移动或复制InnoDB表"></a>14.6.1.2 移动或复制InnoDB表</h5><p>这个部分介绍移动或者拷贝部分或全部InnoDB表到不同的服务器或实例的技术.例如,你也许想把整个MySQL实例移动到一个更大,更快的服务器上去;你也许想克隆整个MySQL实例到一个新的主从同步的从服务器上去;你也许要拷贝个别的表到另一个实例上用来开发或者测试应用,或者到一个数据仓库用来产生报表.</p>
<p>在Windows上,InnoDB总是使用小写来存储数据库和表名.用二进制格式移动数据库从Unix到Windows或者从Windows到Unix,使用小写名称来创建所有数据库和表名.一个简便的方法是在创建数据库和表名之前在你的<code>my.cnf</code>或者<code>my.ini</code>文件的<code>[mysqld]</code>部分添加下面的行.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">lower_case_table_names<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>移动或者复制InnoDB表的技术包括:</p>
<ul>
<li>可传输表空间(Transportable Tablespaces)</li>
<li>Mysql企业备份(MySQL Enterprise Backup)</li>
<li>复制数据文件(冷备份方法)(MySQL Enterprise Backup)</li>
<li>导入和导出(mysqldump)(Export and Import )</li>
</ul>
<p><strong>可传输表空间</strong></p>
<p>可传输表空间特性使用<code>FLUSH TABLES ... FOR EXPORT</code>来准备要从一个服务器实例拷贝到另一个的服务器的表.为了能够使用这个特性,InnoDB表的<code>innodb_file_per_table</code>必须为ON,使得每一张InnoDB表都有它自己的表空间.</p>
<p><strong>Mysql企业备份</strong></p>
<p>MySQl企业备份使你可以在一个正在运行的MySQL数据库上以最小的损害产生快照.当MySQL企业备份在拷贝表的时候,读和写操作可以继续.此外,MySQL企业备份可以创建一个压缩过的备份文件并且可以只备份表的一部分.结合MySQL的binlog,你可以进行时间点恢复.MySQL企业备份包括在MySQL企业订阅中.</p>
<p><strong>复制数据文件</strong></p>
<p>你可以简单地移动一个InnoDB数据库通过拷贝冷备份(Cold Backups)相关的所有文件.</p>
<p>InnoDB数据和日志文件在所有平台上是二进制兼容的,有相同的浮点数格式.如果浮点数格式不同但是在你的表中没有使用FLOAT和DOUBLE数据类型的话,过程是一样的:拷贝相关文件.</p>
<p>当你移动或者拷贝每个表的.ibd文件时,源系统和目标系统的数据库文件夹名必须是相同的.存储在InnoDB共享表空间中的表的定义中包括了数据库名.存储在表空间文件中的事务ID和日志序列号也和数据库中的不同.</p>
<p>要移动.ibd文件和相关的表到另一个数据库,使用<code>RENAME TABLE</code>语句.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> db1.tbl_name <span class="keyword">TO</span> db2.tbl_name;</span><br></pre></td></tr></table></figure>

<p>如果你有.ibd文件的”干净”的备份,你可以将其还原到安装的MySQL上,操作如下:</p>
<ol>
<li>在你拷贝了.ibd文件之后这个表不能被删除或者截断,因为这样会改变存储在表空间中的表ID.</li>
<li>使用<code>ALTER TABLE</code>语句删除当前的.ibd文件:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name DISCARD TABLESPACE;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>复制备份的.ibd文件到正确的目录下</li>
<li>使用下面的<code>ALTER TABLE</code>语句来告诉InnoDB使用新的.ibd文件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name IMPORT TABLESPACE;</span><br></pre></td></tr></table></figure>

<p>在这里,一个”干净”的.ibd备份文件要满足下面的要求:</p>
<ul>
<li>.ibd文件中没有未被提交的事务修改</li>
<li>.ibd文件中不能有没有被合并的insert缓存</li>
<li>清除操作(purge)已经移除了.ibd文件中的全部被标记删除的索引.</li>
<li>mysqld已经把所有被修改的页面都从缓冲池刷到了.ibd文件中.</li>
</ul>
<p>你可以使用下面的方法来制作一个”干净”的.ibd文件:</p>
<ol>
<li>停止mysqld服务的全部活动和提交所有的事务.</li>
<li>等到<code>SHOW ENGINE INNODB STATUS</code>显示数据库没有活动的事务并且InnoDB的主线程状态是<em>waiting for server activity</em>之后,你可以复制一个.ibd文件.</li>
</ol>
<p>另一个制作干净的.ibd文件的办法是使用MySQL企业备份:</p>
<ol>
<li>使用MySQL企业备份备份InnoDB的安装</li>
<li>在备份上启动第二个mysqld服务来清理.ibd文件</li>
</ol>
<p><strong>导入和导出</strong></p>
<p>你可以使用mysqldump转存你的表然后在另一台机器上导入转存的文件.使用这种方式,格式是否一样或你的表包含浮点数据都没关系.</p>
<p>一个提高性能的方法是在导入数据的时候关闭自动提交(autocommit),如果表空间有足够的空间用于导入事务生产的大回滚段(rollback segment).在导入表或者表的一部分后手动执行提交.</p>
<h5 id="14-6-1-3-把表从MyISAM转换到InnoDB"><a href="#14-6-1-3-把表从MyISAM转换到InnoDB" class="headerlink" title="14.6.1.3 把表从MyISAM转换到InnoDB"></a>14.6.1.3 把表从MyISAM转换到InnoDB</h5><p>如果你想要以更高的可靠性和更好的拓展性把MyISAM表转换成InnoDB表的话,在进行转换之前查看下面的引导:</p>
<p><strong>调整MyISAM和InnoDB的内存使用</strong></p>
<p>当你在转换MyISAM表的时候,降低<code>key_buffer_size</code>配置的值来释放不需要的缓存结果.提高<code> innodb_buffer_pool_size</code>配置的值,它扮演了类似为InnoDB表分配缓存内存的角色.InnoDB的缓冲池同时缓存表数据和索引数据用来加速查询的查找速度和保存查询结果在内存里以重用.</p>
<p>在繁忙的服务器上,关闭查询缓存后运行性能测试.InnoDB缓存池提供了类似的好处,所以查询缓存也许会占用不必要的内存.</p>
<p><strong>处理过长或过短的事务</strong></p>
<p>因为MyISAM表不支持事务,你也许需要把更多注意力放在自动提交(autocommit)配置选项以及<code>COMMIT</code>和<code>ROLLBACK</code>语句上.这些关键字对于允许多会话对InnoDB表的并发读写很重要,对于写入繁重的工作来说提供了坚实的可拓展性优势.</p>
<p>当一个事务打开的时候,系统会保存一个事务开始时的数据快照,如果在事务保持运行的时候系统进行了百万行杂散的插入,更新和删除操作的话会造成大量的开销.因此,请注意避免运行时间过长的事务:</p>
<ul>
<li>如果你使用一个mysql会话来进行交互性实验,在结束的时候总是进行<code>COMMIT</code>或<code>ROLLBACK</code>.关闭交互式会话而不是长时间保持开启,来避免意外地长时间保持一个事务在开启状态.</li>
<li>确保你应用中的任何错误处理也会使用<code>ROLLBACK</code>回滚未完成的更改或<code>COMMIT</code>提交已完成的更改.</li>
<li><code>ROLLBACK</code>是一个相对开销比较大的操作,因为<code>INSERT</code>,<code>UPDATE</code>和<code>DELETE</code>操作在<code>COMMIT</code>操作之前都被写入到了InnoDB表中,因为大部分的改变都会被成功的提交并且很少被回滚.在实验大量数据时,避免改变大量的行然后回滚这些变动.</li>
<li>使用<code>INSERT</code>语句加载大量数据时,定期使用<code>COMMIT</code>提交结果来避免长达几小时的事务.在典型的数据仓库加载操作中,如果出了问题,使用<code>TRUNCATE TABLE</code>来重新开始而不是使用<code>ROLLBACK</code>.</li>
</ul>
<p>前面的提示可以减少长时间事务中内存和磁盘的浪费.当事务比它应当的大小更小时,问题更多出在I&#x2F;O上.对于每一个<code>COMMIT</code>,MySQL都会确保每一个变更都安全地记录到磁盘上了,这会涉及到一些I&#x2F;O.</p>
<ul>
<li>对于InnoDB表的多数操作,你应该使用<em>autocommit&#x3D;0</em>的设置.从效率的角度来看,这避免了在你提交大量连续的<code>INSERT</code>,<code>UPDATE</code>或<code>DELETE</code>时候的不必要的I&#x2F;O.从安全的角度来看,这允许你使用<code>ROLLBACK</code>语句来恢复丢失或者乱码的数据,在你在mysql命令行犯了错误或者你的应用进行错误处理的时候.</li>
<li>当运行一系列的查询来生成报告或进行分析统计的时候<em>autocommit&#x3D;1</em>对于InnoDB表来说是合适的.在这种情况下,没有与<code>COMMIT</code>和<code>ROLLBACK</code>相关的I&#x2F;O,InnoDB可以自动地优化只读的工作负载.</li>
<li>如果你进行了一系列的相关更改,最后用一个<code>COMMIT</code>来完成全部的更改.例如,如果你把相关的信息插入到几个表中,使用一个<code>COMMIT</code>进行所有的更改.或者你运行许多连续的<code>INSERT</code>语句然后在所有数据被加载之后使用一个<code>COMMIT</code>;如果你在运行百万行的<code>INSERT</code>语句,也许通过使用<code>COMMIT</code>每次提交一万或十万条记录来拆散这个大事务可以使得事务不会变得太大.</li>
<li>请记住,甚至一个<code>SELECT</code>语句也会打开一个事务,所以在mysql交互式会话中运行一些报告或者调试的查询之后,执行一个<code>COMMIT</code>或者关闭mysql会话.</li>
</ul>
<p><strong>处理死锁(Deadlocks)</strong></p>
<p>你也许会在MySQL错误日志看到一些警告信息提到死锁或者在<code>SHOW ENGINE INNODB STATUS</code>的输出中.尽管名字听起来很可怕,但是对于InnoDB表来说这个问题一点都不严重并且通常不需要任何的纠正动作.当两个事务开始修改多张表的时,它们以不同的顺序访问表,可以到达一种状态:每一个事务都在等在其他的事务并且都不能继续下去.当死锁检测(deadlock detection)开启的时候(默认开启),MySQL会马上检测到这种情况并且取消(rollback)”较小”的事务,允许另一个继续下去.如果死锁检测被<code>innodb_deadlock_detect</code>选项配置禁用的话,InnoDB会根据<code>innodb_lock_wait_timeout</code>设置回滚发生死锁的事务.</p>
<p>无论哪种方式,你的应用都需要一个错误处理逻辑来重启由于死锁被强制取消的事务.当你提交了和之前相同的sql语句,原来提交的就不会被接受了.如果另一个事务已经完成那么你可以继续,另一个事务还在处理中那么就要等到它结束.</p>
<p>如果死锁警告持续发生,你也许需要重审你的应用代码,以一致的方式编排SQL语句或者缩短事务.你可以开启<code>innodb_print_all_deadlocks</code>配置进行测试用以在MySQL错误日志中看到全部的死锁警告,要比查看<code>SHOW ENGINE INNODB STATUS</code>的输出只能看到最后一个警告好得多.</p>
<p><strong>规划存储布局</strong></p>
<p>为了InnoDB表获得最好的性能,你可以调整和存储布局相关的一些参数.</p>
<p>当你转换一个大的,经常使用并且保存重要数据的MyISAM表的时候,调查并考虑<code>innodb_file_per_table</code>,<code>innodb_file_format</code>和<code>innodb_page_size</code>配置选项,以及<code>CREATE TABLE</code>语句中的<code>ROW FORMAT</code>和<code>KEY BLOCK SIZE</code>选项.</p>
<p>在你的初始实验期间,最重要的设置是<code>innodb_file_per_table</code>.当这个设置启用的时候(MySQL5.6.6之后是默认值),新的InnoDB表会被隐式的创建在单表单文件(file-per-table)表空间里.和InnoDB系统表空间相比,单表单文件表空间允许操作系统在表被删除和截断(truncate)后回收磁盘空间.单表单文件的表空间也支持 Barracuda文件格式以及相关的特性,例如:表压缩,可变长的长列的页外效率存储和大索引前缀.</p>
<p>你也可以把InnoDB表存储在共用的通用表空间里.通用表空间支持Barracuda文件格式并且包含多个表.</p>
<p><strong>转换现有表</strong></p>
<p>使用下面的sql:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong><br>不要把在mysql库中的MySQL系统表从MyISAM转换到InnoDB.这是一项不受支持的操作.</p>
</blockquote>
<p><strong>克隆一个表的结构</strong></p>
<p>你可以通过克隆一个MyISAM表来创建InnoDB表而不是使用<code>ALTER TABLE</code>进行转换,在转换之前要在新旧表的两边进行测试.</p>
<p>用相同的列和索引的定义来创建一个空的InnoDB表.使用<code>SHOW CREATE TABLE table_name\G</code>来查看建表时使用的完整的语句.把<code>ENGINE</code>部分改成<code>ENGINE=INNODB</code>.</p>
<p><strong>传输现有数据</strong></p>
<p>把大量的数据传输到如上面所示的空的InnoDB表中,使用<code>INSERT INTO innodb_table SELECT * FROM myisam_table ORDER BY primary_key_columns</code>来插入行.</p>
<p>你也可以在数据插入结束后为InnoDB表创建索引.在以前,创建一个新的二级索引对InnoDB来说是一个比较慢的操作,但是现在你可以在数据加载结束之后创建索引而索引创建步骤的开销相对较小.</p>
<p>如果你对二级键有<code>UNIQUE</code>约束,你可以在导入操作期间暂时性的关闭唯一性检查来加入表的导入:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> unique_checks<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">... import operation ...</span><br><span class="line"><span class="keyword">SET</span> unique_checks<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>对于大表来说可以节省磁盘I&#x2F;O,因为InnoDB可以使用变更缓冲区(change buffer)对二级索引进行批量的写入.要确保数据不包含重复键.唯一性检查( unique_checks)允许但不要求存储引擎忽略重复键.</p>
<p>为了更好地控制插入过程，您可以用下面的代码块插入大型表格:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> newtable <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> oldtable</span><br><span class="line">   <span class="keyword">WHERE</span> yourkey <span class="operator">&gt;</span> something <span class="keyword">AND</span> yourkey <span class="operator">&lt;=</span> somethingelse;</span><br></pre></td></tr></table></figure>

<p>在插入了所有数据后,你可以重命名表.</p>
<p>在转换大表期间,增加InnoDB缓冲池的大小来减少磁盘I&#x2F;O,最大设置物理内存的80%.你也可以增加InnoDB日志文件的大小.</p>
<p><strong>存储要求</strong></p>
<p>如果你打算在转换过程中创建多个InnoDB表数据的临时拷贝,建议你在单表单文件表空间中创建表以便在删除表的时候回收磁盘空间.当<code>innodb_file_per_table</code>配置选项启用的时候(默认启用),新创建的表会被隐式的创建到每个表的表空间文件中去.</p>
<p>无论你是直接转换到InnoDB表还是创建InnoDB的克隆表,确保在此过程中有足够的磁盘空间来容纳旧表和新表.<em>InnoDB表比MyISAM表需要更多的磁盘空间</em>.如果<code>ALTER TABLE</code>操作空间不足的话会开启回滚,如果受到磁盘限制的话,可能需要几小时.对于插入,InnoDB使用插入缓存将二级索引批量合并到索引中.这能节省大量磁盘I&#x2F;O.对于回滚没有使用这样的机制,(所以)回滚可能比插入时间长30倍.</p>
<p>在回滚失控的情况下,如果你的数据库里没有有价值的数据,建议杀死数据库进程而不是等到数百万的磁盘I&#x2F;O完成.</p>
<p><strong>给每个表定义一个主键</strong></p>
<p><code>PRIMARY KEY</code>子句是MySQL查询和表和索引的使用情况的一个重要影响因子.主键唯一标识表中的行.表中的每一行都一定有一个主键并且没有两行会有相同的主键.</p>
<p>下面是主键的准则和详细的解释:</p>
<ul>
<li>对每一个表声明一个主键.通常,它是在查找单行时在WHERE子句中引用的最重要的列.</li>
<li>在<code>CREATE TABLE</code>建表语句时指定主键要比建表之后使用<code>ALTER TABLE</code>指定要好.</li>
<li>仔细选择列的数据类型.首选数字列而不是字符或者字符串.</li>
<li>考虑使用自增列如果表中没有其他稳定的,不重复的,非空的数组列使用的话.</li>
<li>如果对主键的值是否会发生变化有疑问的话,自增的列也是一个好选择.更改主键列的值是一个代价高昂的操作,可能涉及重新排列表格中的数据和每一个二级索引.</li>
</ul>
<p>考虑将主键添加到还没有使用的表中.基于项目最大的大小来使用最小的数字类型.这可以使得列之间更加紧凑,这可以为大表节省大量空间.如果表具有二级索引的话,节省的空间是成倍增加的,因为主键值在每个二级索引中重复.除了减少磁盘上的数据大小,一个小的索引也使得更多的数据进入缓冲池,加速各种操作和提高了并发.</p>
<p>如果表已经在一些大的列上有了索引,例如<code>VARCHAR</code>,考虑增加一个新的自增的无符号列并且把主键切换到上面,即使查询中没有使用这列.这种改变可以在二级索引中节省大量空间.你可以将以前的主键列指定为<code>UNIQUE NOT NULL</code>来确保其和主键有相同的约束来防止这些列出现重复和空值.</p>
<p>如果你在多个表中传递信息,通常对每个表使用相同的列作为主键.例如,一个人员数据库可能有几张表,每一张都用员工号来做主键.销售数据库可能有一些表用顾客编号来做主键并且另一些表以订单ID做主键.因为使用主键的查找速度非常快,你可以对每张表构建有效的连接查询.</p>
<p>如果你不使用<code>PRIMARY KEY</code>子句,Mysql会为你创建一个不可见的.它是一个6位的值可能比你要的还长,这会浪费空间而且你不能在查询中引用它(因为是不可见的).</p>
<p><strong>应用程序性能注意事项</strong></p>
<p>InnoDB的可靠性和可拓展性特性使得其相对于MyISAM表来说需要更多的磁盘空间.你可以稍微更改列和索引定义,为了更好地利用空间,在处理结果集的时候减少I&#x2F;O和内存消耗,以及使用索引查找的时候更好的查询优化计划来提高效率.</p>
<p>如果你使用数字ID作为主键,使用这个值和其他表中相关的值进行交叉引用,特别是join查询.例如,不是接受一个国家名称作为输入进行查询和使用相同的名称进行查询,而是执行一次查找确定国家ID,然后执行在其他表中查询相关信息的查询.不是将客户或目录编号作为数字串,而是使用几个字节转化为数字ID来进行存储和查询.一个4位的无符号整数列可以索引超过40亿件物品.</p>
<p><strong>了解InnoDB表关联的文件</strong></p>
<p>InnoDB文件比MyISAM文件需要更多的关注和计划.</p>
<ul>
<li>你不能删除InnoDB系统表空间中的ibdata文件</li>
<li>移动和拷贝InnoDB表到不同的服务器参考<strong>14.6.1.2 移动和复制InnoDB表</strong></li>
</ul>
<h5 id="14-6-1-4-InnoDB中的自增处理"><a href="#14-6-1-4-InnoDB中的自增处理" class="headerlink" title="14.6.1.4 InnoDB中的自增处理"></a>14.6.1.4 InnoDB中的自增处理</h5><p>InnoDB提供了一种可配置的锁机制可以显著提高向具有自增(AUTO_INCREMENT)列的表添加数据时的可扩展性和性能.为了在InnoDB表中使用自增机制,一个自增列必须被定义为索引的一部分,这样就可以在表上执行等效的被索引的<code>SELECT MAX（ai_col）</code>查找以获得最大列值.通常,这是通过在某些表中使列成为第一列来实现的.</p>
<p>这个部分描述了自增(AUTO_INCREMENT)锁的行为模式,不同设置模式的含义和InnoDB如何初始化自增计数器.</p>
<p><strong>InnoDB自增锁模式(InnoDB AUTO_INCREMENT Lock Modes)</strong></p>
<p>这个部分描述了自增锁模式被用来生成自增值时候的行为以及每种锁模式如何影响复制.自增锁模式的配置参数是<code>innodb_autoinc_lock_mode</code></p>
<p>下面是<code>innodb_autoinc_lock_mode</code>配置的描述:</p>
<ul>
<li><p><code>INSERT-like</code>子句</p>
<p>在表中生成新行的所有语句,包括<code>INSERT</code>,<code>INSERT ... SELECT</code>,<code>REPLACE</code>,<code>REPLACE ... SELECT</code>和<code>LOAD DATA</code>.包括简单插入(simple-inserts),批量插入(bulk-inserts)和混合模式插入(mixed-mode).</p>
</li>
<li><p>简单插入(simple-inserts)</p>
<p>语句中可以预先确定要插入的行数.这包括没有嵌套子查询的单行和多行的插入以及替换语句但是不包括<code>INSERT ... ON DUPLICATE KEY UPDATE</code>.</p>
</li>
<li><p>批量插入(bulk-inserts)</p>
<p>语句中预知要插入的行数.包括<code>INSERT ... SELECT</code>,<code>REPLACE ... SELECT</code>和<code>LOAD DATA</code>语句,但不是普通的<code>INSERT</code>.InnoDB在处理每一行的时候都为自增列生成一个新值.</p>
</li>
<li><p>混合模式插入(mixed-mode)</p>
<p>这些是简单插入语句但是指定了其中的一些自增列的值.例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (c1,c2) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>), (<span class="keyword">NULL</span>,<span class="string">&#x27;b&#x27;</span>), (<span class="number">5</span>,<span class="string">&#x27;c&#x27;</span>), (<span class="keyword">NULL</span>,<span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>另一种混合模式插入是<code>INSERT ... ON DUPLICATE KEY UPDATE</code>,最坏的情况下是在INSERT后面加一个UPDATE,在更新阶段可能会或不会使用自增列的已分配的值.</p>
</li>
</ul>
<p><code>innodb_autoinc_lock_mode</code>有3种可能的设置参数.分别是0,1,2代表传统的(traditional),连续的(consecutive)和交叉的(interleaved)锁模式.</p>
<ul>
<li><p>innodb_autoinc_lock_mode &#x3D; 0(传统锁模式)</p>
<p>传统锁模式提供了和MySQL5.1引入<code>innodb_autoinc_lock_mode</code>配置之前相同的行为.提供传统锁模式选项是为了向后兼容,性能测试以及解决”混合模式插入”问题,因为在语义上可能存在差异.</p>
<p>在这个锁模式下,所有”INSERT-like”语句都会获得一个特殊的表级<code>AUTO-INC</code>锁,用来插入有自增列的表.此锁通常保持在插入语句的末尾(而不是事务的末尾)来确保对于给定的一系列插入语句能够以可预测和可重复的顺序为其分配自增值,并且确保对于任意给定的语句自增值都是连续的.</p>
<p>在基于语句复制的情况下,在slave上执行sql语句的时候会使用与master在自增列上相同的值.执行多个插入语句的结果是确定的并且slave上产生的数据和master是相同的.如果多个插入语句生成的自增值是交错的,那么两个并发的INSERT操作产生的结果是不确定的并且使用基于语句的复制传递到slave的数据是不可靠的.</p>
<p>为了清楚起见,使用下面的示例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">  c1 <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  c2 <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (c1)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>假设有2个事务在运行,每一个插入的行都有一个自增的列.一个事务使用<code>INSERT ... SELECT</code>语句插入1000行,另一个使用简单的<code>INSERT</code>插入操作.  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tx1: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (c2) <span class="keyword">SELECT</span> <span class="number">1000</span> <span class="keyword">rows</span> <span class="keyword">from</span> another <span class="keyword">table</span> ...</span><br><span class="line">Tx2: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (c2) <span class="keyword">VALUES</span> (<span class="string">&#x27;xxx&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>InnoDB无法预知Tx1事务到底SELECT了多少行进行插入,所以随着语句的执行每次分配一个自增的值.由于使用保持在语句末尾的表级锁,在t1表上同时只能有一个插入语句执行,并且不同的插入语句生成的自增的数值也是无关的.所以Tx1事务中生成的数值是自增的而Tx2中的自增数值比Tx1大还是小取决于两个事务哪个先执行.</p>
<p>只要以相同的顺序执行binlog中的sql语句,结果就和Tx1和Tx2第一次执行时一样.因此,保持到语句结束的表级锁使得使用自动增量的插入语句可以安全地用于基于语句的复制.但是,当多个事务同时执行插入语句的时候,表级锁限制了并发性和可伸缩性.</p>
<p>在上面的例子里,如果没有表级锁,Tx2事务的插入语句中自增列的值就取决于语句执行的时间.如果Tx2的插入语句在Tx1插入语句正在执行的时候执行,这两个插入语句产生的自增列的值就变得不确定了,而且每次运行都可能不同.</p>
<p>在”连续锁”模式下,InnoDB可以避免对能够预先知道插入行数的”简单插入”语句使用表级的<code>AUTO-INC</code>锁,并且仍旧保持执行顺序的确定性和基于语句复制的安全性.</p>
<p>如果你不使用binlog重播sql语句(的形式)作为恢复或复制的一部分,交错锁模式(interleaved lock mode)可用于消除所有表级锁<code>AUTO-INC</code>的使用来实现更高的并发和性能,以允许语句产生的自增数的差距和由于并发产生自增数字交错为代价.</p>
</li>
<li><p>innodb_autoinc_lock_mode &#x3D; 1 (连续锁模式)</p>
<p>这是默认的锁模式.在这种模式下,批量插入使用了特殊的<code>AUTO-INC</code>表级锁并且保持到语句结束.适用于所有<code>INSERT ... SELECT</code>,<code>REPLACE ... SELECT</code>和<code>LOAD DATA</code>语句.同时只能有一个语句持有<code>AUTO-INC</code>锁.如果批量插入的原表和目标表不同,<code>AUTO-INC</code>锁会在从原表第一行获取了共享锁之后对目标表加锁.如果原表和目标表相同的话,<code>AUTO-INC</code>锁会在获取了共享锁之后对所有被SELECT的行加锁.</p>
<p>“简单插入”(预先知道行数的插入)通过在互斥锁(一个轻量锁)的控制下获得所需的自增值的数量来避免表级的<code>AUTO-INC</code>锁,互斥锁只会在分配的过程中持有,而不是直到语句执行结束之后.除非有另一个事务持有<code>AUTO-INC</code>锁,否则不会使用<code>AUTO-INC</code>锁.如果另一个事务持有<code>AUTO-INC</code>锁,简单插入会等待<code>AUTO-INC</code>释放,就像批量插入一样.</p>
<p>这种锁模式确保在不知道给定的INSERT语句要插入的行数的情况下,所有<code>INSERT-like</code>的语句分配的自增值都是连续的,并且基于语句的复制是安全的.</p>
<p>简而言之,这种锁模式显著的提高了可伸缩性同时可以安全的使用基于语句的复制.此外,和传统锁模式一样给任意语句的自增值都是连续的.对于任何有自动增量的语句,与传统模式相比语义上没有变化,但是有一个重要的例外.</p>
<p>这个例外是对于”混合模式”插入,因为用户提供了其中的一部分自增列的值,InnoDB申请的自增列的数量会比需要的量更多,但是因为自增列的值生成都是连续的,所以后执行的插入语句的值会高于之前的,(前一个语句)多出来的数值就丢失了.</p>
</li>
<li><p>innodb_autoinc_lock_mode &#x3D; 2 (交错锁模式)</p>
<p>在这种锁模式下,任何插入相关的语句都不会使用<code>AUTO-INC</code>锁,多个语句可能同时执行.这是最快和最具扩展性的锁模式,但是使用基于从binlog回放语句的复制或恢复的时候,这是不安全的.</p>
<p>在这种模式下,自增的值保证是唯一的并且在所有执行的插入语句中单调递增,但是并发的插入会导致生成的自增值会产生交错,所以对于一个插入语句来说里面的自增值可能是不连续的.</p>
<p>如果唯一执行的语句是在插入之前知道要插入的行数的简单插入语句那么单个语句生成的自增值之间是没有间隙的,除了”混合模式插入”.然而,当执行批量插入的时候,任何给定的语句中的自增数值可能存在间隙.</p>
</li>
</ul>
<p><strong>InnoDB 自增锁模式的使用含义(InnoDB AUTO_INCREMENT Lock Mode Usage Implications)</strong></p>
<ul>
<li><p>使用自增(auto-increment)进行复制</p>
<p>如果你使用基于语句的复制,在master和slave上把<code>innodb_autoinc_lock_mode</code>设置成相同的值(0或1).如果你设置”innodb_autoinc_lock_mode &#x3D; 2”或者主从不使用相同的锁模式则不能保证主从上的自增键的值是相同的.</p>
<p>如果你使用基于行或者混合格式的复制,任何一个模式都是安全的因为基于行的复制对于sql的执行顺序不敏感(混合格式就是对不安全的基于语句的复制使用基于行的复制).</p>
</li>
<li><p>丢失自增值和序列间隙(sequence gaps)</p>
<p>在所有的锁模式中(0,1和2),如果生成自增值的事务回滚的话,这些自增值就会丢失.一旦为自增列生成了值,无论是插入的语句没有完成还是包含的事务是否回滚这些生成的值都不能回滚.这些丢失的值不会被重用.因此,表中的自增列可能会存在间隙(sequence gaps).</p>
</li>
<li><p>给自增的列指定NULL或0</p>
<p>在所有的锁模式下,用户在INSERT语句中给自增的列指定NULL或0,InnoDB都会视为这些行没有被指定值然后为其生成一个新值.</p>
</li>
<li><p>给自增的列指定一个负值</p>
<p>在所有锁模式中,如果你给自增列指定一个负值那么就不会给其定义自增的机制.</p>
</li>
<li><p>如果自增列的值大于对应列数据类型的最大值</p>
<p>在所有锁模式下,如果值大于指定整数类型可以存储的最大值就不会给其定义自动增加机制.</p>
</li>
<li><p>批量插入中的自增值的间隙</p>
<p>在<code>innodb_autoinc_lock_mode</code>设置为0(传统的)和1(连续的)时,任何给定的语句生成的自增值都是连续的,没有间隙,因为<code>AUTO-INC</code>锁会保持到语句结束并且同时只能执行一个语句.</p>
<p>在<code>innodb_autoinc_lock_mode</code>设置为2(交错)时,生成批量插入的自增值的时候可能会产生间隙,因为只有这个时候会并行执行多个<code>INSERT-like</code>语句.<br>对于锁模式1和2,在连续的语句之间可能会存在间隙,因为对于批量插入不可能知道每个语句确切需要的数量并且可能会高估.</p>
</li>
<li><p>混合模式插入指定的自增值</p>
<p>考虑一个混合模式插入:在一个简单插入中指定一些(但不是全部)自增值.这样的语句在模式0,1,2中表现不同.例如,假定t1表有一个自增列c1,并且最近生成的自增值是100.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c1 <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY, </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c2 <span class="type">CHAR</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) ENGINE <span class="operator">=</span> INNODB;</span><br></pre></td></tr></table></figure>

<p>现在,考虑下面的混合模式插入的语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (c1,c2) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>), (<span class="keyword">NULL</span>,<span class="string">&#x27;b&#x27;</span>), (<span class="number">5</span>,<span class="string">&#x27;c&#x27;</span>), (<span class="keyword">NULL</span>,<span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>innodb_autoinc_lock_mode</code>为0会产生下面4行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> c2;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br><span class="line"><span class="operator">|</span> c1  <span class="operator">|</span> c2   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span> a    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">101</span> <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">5</span> <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">102</span> <span class="operator">|</span> d    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br></pre></td></tr></table></figure>

<p>下一个可用的自增值是103因为每次分配一个自增值而不是在处理语句时一次性分配.无论是否同时执行了插入语句,结果都是一样的.</p>
<p><code>innodb_autoinc_lock_mode</code>为1会产生下面4行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> c2;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br><span class="line"><span class="operator">|</span> c1  <span class="operator">|</span> c2   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span> a    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">101</span> <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">5</span> <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">102</span> <span class="operator">|</span> d    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br></pre></td></tr></table></figure>

<p>然而这种情况下下一个可用的自增值是105而不是103,因为在处理语句时分配了4个值而只使用了2个.无论是否同时执行了插入语句,结果都是一样的.</p>
<p><code>innodb_autoinc_lock_mode</code>为1会产生下面4行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> c2;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br><span class="line"><span class="operator">|</span> c1  <span class="operator">|</span> c2   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span> a    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   x <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">5</span> <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   y <span class="operator">|</span> d    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br></pre></td></tr></table></figure>

<p>x和y的值是唯一的并且比之前生成的值都大.但是x和y的具体值取决于并发执行语句时生成的自增值.</p>
<p>最后,考虑下面的语句在最近生成的自增值为100时执行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (c1,c2) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>), (<span class="keyword">NULL</span>,<span class="string">&#x27;b&#x27;</span>), (<span class="number">101</span>,<span class="string">&#x27;c&#x27;</span>), (<span class="keyword">NULL</span>,<span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在任何一个<code>innodb_autoinc_lock_mode</code>设置下都会生成一个重复键错误 error 23000(Can’t write; duplicate key in table)因为101是分配给(NULL, ‘b’)这一行的所以插入(101, ‘c’)会失败.</p>
</li>
<li><p>在一系列插入语句中间修改自增列的值</p>
<p>在所有锁模式下,在一系列插入语句中间修改自增列的值都会导致重复条目(Duplicate entry)错误.例如,如果你执行了一个<code>UPDATE</code>操作更改自增列的值为大于当前自增列最大值的话,后续的未指定自增列值的操作可能会遇到重复条目(Duplicate entry)错误.下面是一个演示:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c1 <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">PRIMARY</span> KEY (c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  ) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">0</span>), (<span class="number">0</span>), (<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> c1 <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span> c1 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> c1 <span class="operator">=</span> <span class="number">4</span> <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> c1 <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span> c1 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">0</span>);</span><br><span class="line">ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">&#x27;4&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;PRIMARY&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>InnoDB自增计数器初始化</strong></p>
<p>这个部分介绍InnoDB怎么初始化自增计数器.</p>
<p>如果你为InnoDB表指定一个自增的列,InnoDB数据字典的表句柄会包含一个计数器叫做自增计数器(auto-increment counter)用来给列分配新值.这个计数器只存储在主内存里而不是磁盘上.</p>
<p>为了在服务器重启后重新初始化自增计数器,InnoDB会在包含自增列的表中进行第一次插入时执行和下面等价的语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(ai_col) <span class="keyword">FROM</span> table_name <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>InnoDB会递增这个检索到的值然后将其分配给列和表的自增计数器.默认情况下,自增的值是1.这个默认值可以由<code>auto_increment_increment</code>配置覆盖.</p>
<p>如果表是空的,InnoDB使用1.这个默认值可以由<code>auto_increment_offset</code>覆盖.</p>
<p>如果<code>SHOW TABLE STATUS</code>在自增计数器初始化之前检查该表,InnoDB会初始化(自增计数器)但不会递增该值.这个值会被存储用于用户的下一次插入.这个初始化使用常规独占锁在表上进行读取并且锁会持续到事务结束.InnoDB遵循相同的过程来初始化新建表的自增计数器.</p>
<p>在自增计数器被初始化之后,如果你没有给自增列显式地指定值的话,InnoDB会递增计数器然后给列分配新值.如果插入显式指定自增列值的行并且值比计数器当前值更大的话,计数器会被设置为这个指定的列值.</p>
<p>InnoDB会在服务器运行的时候使用内存中的自增值计数器.当服务器停止并重启时,InnoDB会初始化每个表的计数器用于表的第一次插入.</p>
<p>服务器重启还会取消<code>CREATE TABLE</code>和<code>ALTER TABLE</code>语句中<code>AUTO_INCREMENT = N</code>对表的影响,你可以使用InnoDB表来设置初始计数器的值或更改当前计数器的值.</p>
<h5 id="14-6-1-5-InnoDB和外键约束"><a href="#14-6-1-5-InnoDB和外键约束" class="headerlink" title="14.6.1.5 InnoDB和外键约束"></a>14.6.1.5 InnoDB和外键约束</h5><p><strong>外键定义(Foreign Key Definitions)</strong></p>
<p>InnoDB表的外键定义受到以下约束:</p>
<ul>
<li>InnoDB允许外键引用任何索引或索引组.但是在引用的表中必须有一个被列为<em>first</em>列的列被引用且是以相同的顺序.</li>
<li>InnoDB当前不支持用户定义分区的表的外键.这意味着没有用户分区的InnoDB表可以包含外键引用或被外键引用的列.</li>
<li>InnoDB允许外键约束引用一个非唯一键.这是InnoDB对标准SQL的一个拓展.</li>
</ul>
<p><strong>引用操作(Referential Actions)</strong></p>
<p>InnoDB表的外键引用操作受到下面限制:</p>
<ul>
<li>虽然MySQL服务器允许<code>SET DEFAULT</code>但是InnoDB视其为无效.在<code>CREATE TABLE</code>和<code>ALTER TABLE</code>语句中使用这个子句都不会被InnoDB表允许.</li>
<li>如果在父表中有几行数据有相同的引用键值,InnoDB在外键检查中会起作用就像父表中其他有相同键值的行不存在一样.例如,如果你定义了一个<code>RESTRICT</code>类型约束,并且一个子行有多个父行,InnoDB不允许删除父行中的任何一个.</li>
<li>InnoDB基于索引中对应的外键约束记录通过深度优先算法进行级联操作.</li>
<li>如果<code>ON UPDATE CASCADE</code>或<code>ON UPDATE SET NULL</code>递归更新它在级联期间更新的同一个表,行为就像<code>RESTRICT</code>.这也就意味着你不能在<code>ON UPDATE CASCADE</code>或<code>ON UPDATE SET NULL</code>中使用自我指涉.这是为了防止级联更新导致无限循环.另一方面<code>ON DELETE SET NULL</code>这样的自我指涉是可能的,这个就像<code>ON DELETE CASCADE</code>一样.指涉操作深度不能操作15级.</li>
<li>就像MySQL通常做的,一个SQL语句插入,删除或更新多行,InnoDB逐行检查唯一(UNIQUE)和外键(FOREIGN KEY)约束.执行外键检查时,InnoDB会在需要查看的子记录和父记录上设置共享行级锁.InnoDB会立即检查外键约束;检查不会延迟到事务提交.根据SQL标准,默认行为应该是延迟检查.也就是在处理完整个SQL语句后才会检查约束.在InnoDB实现延迟约束检查之前,有些事是不可能的,例如删除使用外键引用自身的记录.</li>
</ul>
<p><strong>生成列和虚拟索引的外键限制</strong></p>
<ul>
<li>对存储的生成列的外键约束不能使用<code>ON UPDATE CASCADE</code>, <code>ON DELETE SET NULL</code>, <code>ON UPDATE SET NULL</code>, <code>ON DELETE SET DEFAULT</code>, 或 <code>ON UPDATE SET DEFAULT</code>. </li>
<li>外键约束不能引用虚拟生成列.</li>
<li>在5.7.16之前,外键约束不能引用定义在虚拟生成列上的二级索引.</li>
<li>在MySQL5.7.13及之前,InnoDB不允许在索引虚拟生成列的基列上使用级联引用操作定义外键约束.在MySQL 5.7.14解除了这个限制.</li>
<li>在MySQL 5.7.13及更早版本中,InnoDB不允许在显式包含在虚拟索引中的非虚拟外键列上定义级联引用操作.在MySQL 5.7.14中解除了这个限制.</li>
</ul>
<h5 id="14-6-1-6-InnoDB表的限制"><a href="#14-6-1-6-InnoDB表的限制" class="headerlink" title="14.6.1.6 InnoDB表的限制"></a>14.6.1.6 InnoDB表的限制</h5><p><strong>最大值和最小值(Maximums and Minimums)</strong></p>
<ul>
<li><p>一张表最多包含1017列(MySQl5.6.9之前是1000列).虚拟生成列也包含在这个限制里.</p>
</li>
<li><p>一张表最多包含64个二级索引.</p>
</li>
<li><p>如果<code>innodb_large_prefix</code>启用(默认值),对InnoDB使用DYNAMIC或COMPRESSED行格式的表的索引前缀的限制是3072字节.如果<code>innodb_large_prefix</code>禁用,对表的任何行格式索引前缀的限制都是767字节.</p>
<p><code>innodb_large_prefix</code>已弃用,在以后的版本中将删除.<code>innodb_large_prefix</code>在MySQL5.5中引入用来禁用大前缀索引,为了和早期的InnoDB版本兼容.</p>
<p>对于使用REDUNDANT或COMPACT行格式的InnoDB表,索引前缀的限制是767字节.例如,你可能在<code>TEXT</code>或<code>VARCHAR</code>列超过255个字符的时候遇到这个列前缀索引限制,假定是一个utf8mb3字符集,每个字符最大是3个字节.</p>
<p>尝试使用超出限制的索引键前缀长度会返回错误.要避免复制配置中的这类错误,避免在master上开启<code>innodb_large_prefix</code>配置如果在slave上不生效的话.</p>
<p>适用于索引前缀键的限制也适用于全列索引键.</p>
</li>
<li><p>如果在启动MySQL实例时通过修改<code>innodb_page_size</code>将InnoDB页大小减少到8kb或4kb,根据16kb页面3072字节的限制,索引键的最大长度也会按比例降低.8kb最大索引键长度是1536字节,4kb最大索引键长度是768字节.</p>
</li>
<li><p>多列索引最多允许16列,超过限制会返回下面错误:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="number">1070</span> (<span class="number">42000</span>): Too many key parts specified; max <span class="number">16</span> parts allowed</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了可变长列(VARBINARY,VARCHAR,BLOB和TEXT)之外最大行长度略小于4KB,8KB,16KB和32KB的页面大小.例如,<code>innodb_page_size</code>默认的最大行长度是16KB大约8000字节.对64KB大小的InnoDB也来说,最大行长度大概是16000字节.LONGBLOB和LONGTEXT列必须小于4GB,并且包括BLOB和TEXT列的总长度必须小于4GB.<br>如果一行的长度小于半页,所有行都存储在页内.如果超过半页,可变长列会被选择存储到页外部直到行适合半页.</p>
</li>
<li><p>虽然InnoDB内部支持行大小超过65535字节,但是MySQL本身对所有列组合添加65535字节的行大小限制.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (a <span class="type">VARCHAR</span>(<span class="number">8000</span>), b <span class="type">VARCHAR</span>(<span class="number">10000</span>),</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span> c <span class="type">VARCHAR</span>(<span class="number">10000</span>), d <span class="type">VARCHAR</span>(<span class="number">10000</span>), e <span class="type">VARCHAR</span>(<span class="number">10000</span>),</span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span> f <span class="type">VARCHAR</span>(<span class="number">10000</span>), g <span class="type">VARCHAR</span>(<span class="number">10000</span>)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): <span class="type">Row</span> size too large. The maximum <span class="type">row</span> size <span class="keyword">for</span> the</span><br><span class="line">used <span class="keyword">table</span> type, <span class="keyword">not</span> counting BLOBs, <span class="keyword">is</span> <span class="number">65535.</span> You have <span class="keyword">to</span> change <span class="keyword">some</span></span><br><span class="line">columns <span class="keyword">to</span> TEXT <span class="keyword">or</span> BLOBs</span><br></pre></td></tr></table></figure>
</li>
<li><p>在一些旧的操作系统中,文件必须小于2GB.这不是InnoDB自身的限制,但是如果你需要一个大表空间配置其使用几个小的数据文件而不是一个大的数据文件.</p>
</li>
<li><p>InnoDB日志文件总大小可以达到512GB.</p>
</li>
<li><p>最小的表空间大小比10MB稍大.最大表空间大小取决于InnoDB页面大小.</p>
<p><img src="https://i.loli.net/2019/03/01/5c78dfdbdc064.png"> </p>
<p>最大表空间大小也就是表的最大大小.</p>
</li>
<li><p>在Windows32位系统中表空间文件不能超过4GB(Bug #80149).</p>
</li>
<li><p>表空间文件的路径包括文件名,不能超过Windows中最大路径(MAX_PATH)的限制.Windows10中MAX_PATH限制为260个字符.从Windows10 1607版本开始MAX_PATH限制将从常见的Win32文件和目录函数中删除,但是你必须启用新行为.</p>
</li>
<li><p>InnoDB默认页面大小是16KB.你可以在创建MySQL实例的时候通过配置<code>innodb_page_size</code>来增加或减少页面大小.</p>
<p>Barracuda文件格式中的ROW_FORMAT&#x3D;COMPRESSED假定页面大小最多16KB并且使用14位指针.</p>
<p>支持32KB和64KB页面大小,但是 ROW_FORMAT&#x3D;COMPRESSED不支持不支持超过16KB的页面大小.对于32KB和64KB页面大小最大记录大小是16KB.<code> innodb_page_size=32k</code>范围为2MB,<code> innodb_page_size=32k</code>范围是4MB.</p>
<p>使用特定页面大小的Mysql实例不能使用来自不同页面大小实例的数据文件和日志文件.</p>
</li>
</ul>
<p><strong>InnoDB表的限制</strong></p>
<ul>
<li><p><code>ANALYZE TABLE</code>通过在每个索引树上执行随机下潜(random dives)来确定索引基数和更新相应的索引基数.因为只是估计,重复运行<code>ANALYZE TABLE</code>可能产生不同的数值.这使得在InnoDB表上<code>ANALYZE TABLE</code>很快但不是100%准确,因为不会考虑所有行.</p>
<p>可以通过开启<code> innodb_stats_persistent</code>选项使得<code>ANALYZE TABLE</code>更精确更稳定.启用该设置后,在对索引列数据进行重要更改后运行<code>ANALYZE TABLE</code>非常重要,因为统计数据不会定期重新计算(比如服务器重启).</p>
<p>如果启用了持久统计信息设置,你可以通过修改<code> innodb_stats_persistent_sample_pages</code>系统变量来改变随机下潜(random dives)的次数.如果禁用持久统计信息设置,修改<code> innodb_stats_transient_sample_pages</code>来代替.</p>
<p>MySQL在join优化中使用索引基数估计.如果join操作没有被正确优化,尝试使用<code>ANALYZE TABLE</code>.在少数情况下,<code>ANALYZE TABLE</code>不能为特定的表生成足够好的值,你可以对查询使用<code>FORCE INDEX</code>来强制使用特定索引或通过设置<code>max_seeks_for_key</code>系统变量来确保MySQL优先考虑通过表扫描进行索引查找.</p>
</li>
<li><p>如果语句或事务正在表上运行,一个<code> ANALYZE TABLE</code>运行在相同的表上紧接着第二个<code> ANALYZE TABLE</code>操作,第二个<code> ANALYZE TABLE</code>操作会被阻止直到语句或事务完成.这个问题出现的原因是<code> ANALYZE TABLE</code>结束运行后会使得当前加载表被定义为已过时.新语句或事务(包括第二个<code> ANALYZE TABLE</code>语句)必须将新表加载到表缓存中,在完成当前运行的语句或事务并清除表的已过时定义之前(加载新表)这种情况是不会发生的.加载多个并发表定义是不支持的.</p>
</li>
<li><p><code>SHOW TABLE STATUS</code>不能给出InnoDB表的确切信息除了表格保留的物理尺寸.行计数只是SQL优化中使用的粗略估计.</p>
</li>
<li><p>InnoDB不保留表中的内部行数,因为并发事务可能同时”看到”不同数量的行.因此,<code>SELECT COUNT(*)</code>语句只计算当前事务可见的行数.</p>
</li>
<li><p>在Windows上,InnoDB始终在内部以小写的形式存储数据库和表名.要以二进制格式将数据库从Unix移动到Windows或从Windows移动到Unix,使用小写名创建所有的数据库和表.</p>
</li>
<li><p>必须将自增列<code>ai_col</code>定义为索引的一部分,以便在表上执行和<code>SEELCT MAX(ai_col)</code>等效的索引查找时获取最大值.通常这是通过是列成为某些表索引的第一列来实现的.</p>
</li>
<li><p>InnoDB在初始化表上先前指定的自增列时在自增列相关的索引末尾设置独占锁.</p>
<p><code> innodb_autoinc_lock_mode=0</code>时,InnoDB使用特殊的<code>AUTO-INC</code>表级锁模式,在此模式下获取锁并在访问自动增量计数器时保持到当前SQL语句的末尾.在保持AUTO-INC表锁时，其他客户端无法插入表中.使用<code>innodb_autoinc_lock_mode = 1</code>的”批量插入”时也会出现相同的行为.表级锁<code>AUTO-INC</code>不与<code>innodb_autoinc_lock_mode = 2</code>一起使用</p>
</li>
<li><p>当你重新启动MySQL服务器时,InnoDB可能会重复使用为自增列生成但从未存储过的旧值(也就是在回滚的旧事务期间生成的值).</p>
</li>
<li><p>当自增整数列用完值时，后续INSERT操作将返回重复键错误(duplicate-key error).这是正常的MySQL行为.</p>
</li>
<li><p><code>DELETE FROM tbl_name</code>不会重新生成表,而是逐个删除所有行.</p>
</li>
<li><p>级联外键操作不会激活触发器.</p>
</li>
<li><p>您不能创建一个列名与内部InnoDB列的名称匹配的表(包括DB_ROW_ID, DB_TRX_ID, DB_ROLL_PTR 和 DB_MIX_ID).此限制适用于把名称任何字母小写的情况.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="type">INT</span>, db_row_id <span class="type">INT</span>) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line">ERROR <span class="number">1166</span> (<span class="number">42000</span>): Incorrect <span class="keyword">column</span> name <span class="string">&#x27;db_row_id&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>锁和事务(Locking and Transactions)</strong></p>
</li>
</ul>
<p>如果<code>innodb_table_locks=1</code>(默认值)<code>LOCK TABLES</code>会在每个表上获取2个锁.除了MySQL层面上的表锁也需要InnoDB的表锁.MySQL 4.1.2之前版本不需要InnoDB表锁;通过设置<code>innodb_table_locks=0</code>来使用这种旧的行为.如果没有获取InnoDB表锁,即使表的某些记录被其他事务锁定,<code>LOCK TABLES</code>也会完成.</p>
<p>  在MySQL 5.7中,<code>innodb_table_locks=0</code>对于使用<code> LOCK TABLES ... WRITE</code>显式锁定表没有任何影响.它对隐式的<code>LOCK TABLES ... WRITE</code>(例如通过触发器)或<code>LOCK TABLES ... READ</code>有效.</p>
<ul>
<li>事务提交或中止时,将释放事务持有的所有InnoDB锁.因此,在<code>autocommit = 1</code>模式下在InnoDB表上调用<code>LOCK TABLES</code>没有多大意义,因为获取的InnoDB表锁将立即释放.</li>
<li>你无法在事务中锁定其他表,因为<code>LOCK TABLES</code>隐式执行<code>COMMIT</code>和<code>UNLOCK TABLES</code>.</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://misakatang.cn/2019/02/18/InnoDB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-14-4-InnoDB-%E6%9E%B6%E6%9E%84-14-5-InnoDB-%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/misaka.jpg">
      <meta itemprop="name" content="MisakaTang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MisakaTang's Blog">
      <meta itemprop="description" content="The limits of my language are the limits of my world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | MisakaTang's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/18/InnoDB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-14-4-InnoDB-%E6%9E%B6%E6%9E%84-14-5-InnoDB-%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">InnoDB官方文档--14.4 InnoDB 架构|14.5 InnoDB 在内存中的结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-18 22:38:17" itemprop="dateCreated datePublished" datetime="2019-02-18T22:38:17+00:00">2019-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-14 08:33:24" itemprop="dateModified" datetime="2024-03-14T08:33:24+00:00">2024-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="14-4-InnoDB-架构"><a href="#14-4-InnoDB-架构" class="headerlink" title="14.4 InnoDB 架构"></a>14.4 InnoDB 架构</h3><p><img src="https://dev.mysql.com/doc/refman/5.7/en/images/innodb-architecture.png"></p>
<h3 id="14-5-InnoDB-在内存中的结构"><a href="#14-5-InnoDB-在内存中的结构" class="headerlink" title="14.5 InnoDB 在内存中的结构"></a>14.5 InnoDB 在内存中的结构</h3><h4 id="14-5-1-缓冲池-Buffer-Pool"><a href="#14-5-1-缓冲池-Buffer-Pool" class="headerlink" title="14.5.1 缓冲池(Buffer Pool)"></a>14.5.1 缓冲池(Buffer Pool)</h4><p>缓冲池是一个用来缓存被访问的表和索引数据的在主存储中的区域.缓冲池允许直接从内存中处理常用数据用来加快处理速度.在专用服务器上,通常给缓冲池分配80%的内存.</p>
<p>为了大量读操作的处理效率,缓冲池被分成了可能有多行数据的页面.为了缓存管理的效率,缓冲池被实现为页面相连为列表(list)的形式,使用LRU算法使得很少使用的数据在缓存中老化.</p>
<p>了解如何利用缓冲池将频繁访问的数据保存在内存中是MySQL调优的一个重要方面.</p>
<p><strong>缓冲池的LRU(最近最少使用)算法</strong></p>
<p>缓冲池是一个使用最近最少使用(least recently used)算法变种管理的列表.当需要空间来向缓冲池中插入新页面的时候,最近最少使用的页面被赶出,新页面被加到列表的中间.中间插入策略把列表看做两个子列表:</p>
<ul>
<li>在头部是一个最近被访问的”年轻的”列表</li>
<li>在尾部是一个最近访问较少的列表</li>
</ul>
<p>缓冲池列表示意图:</p>
<p><img src="https://dev.mysql.com/doc/refman/5.7/en/images/innodb-buffer-pool-list.png"></p>
<p>该算法保留了新子列表(new sublist)中查询时大量使用的页面.旧子列表(old sublist)中包含了较少使用的页面,这些页面被视为驱逐(evicted)的候选.</p>
<p>默认情况下,算法的操作如下:</p>
<ul>
<li>3&#x2F;8的缓冲池被分给旧子列表</li>
<li>列表的中点是新子列表的尾部和旧子列表头部相交的地方.</li>
<li>当InnoDB从缓冲池中读取了一个页面,将其插入到中点(旧子列表的头部).一个页面被读取的原因是用户的特定操作例如一个SQL查询或者是InnoDB自动的预读(read ahead)操作.</li>
<li>访问旧子列表中的页面会使其变”年轻”,将其移动到缓冲池的头部(新子列表的头部).如果页面是因为被需要而读取,第一次访问会立即发生并且页面变得”年轻”.如果页面是因为预读被读取,第一次访问就不会立即执行.</li>
<li>随着数据库的运行,缓冲池中的页面会随着未访问年龄的增大而向列表尾部移动.新旧子列表中的页面都会随着其他页面的变化而变旧.旧子列表中的页面会随着页面向中点插入而逐渐老化.最终,未被使用的页面到达旧子列表的尾部后被赶出(内存).</li>
</ul>
<p>在默认情况下,查询导致读取的页面会立即移动到新子列表中,意味着其可以在缓冲池中待得更久.一个表扫描(例如mysqldump或者没有where子句的select语句)会把大量的数据带进缓冲池并且赶出等量的旧数据哪怕这些新数据不会被再次使用.相似的,由后台预读线程加载页面移到新列表的头部然后只访问一次.这些情况会将经常使用的页面推到旧子列表中,在那里页面会被赶出内存.</p>
<p>InnoDB标准监视器输出包含几个和LRU算法相关的字段在<code>BUFFER POOL AND MEMORY</code>中.</p>
<p><strong>缓冲池配置</strong></p>
<p>你可以从多个方面配置缓冲池来提高性能</p>
<ul>
<li>理想情况下,你可以在不影响服务器其他进程的情况下把缓冲池的内存设的尽可能的大.缓冲池越大InnoDB就越像一个内存型数据库,从磁盘上读取一次然后在后续的访问中从内存读取数据.</li>
<li>在有足够内存的64位系统上,你可以把缓冲池拆分为多个部分来最大限度减少并发操作对内存结构的竞争.</li>
<li>你可以把频繁访问的数据保留在内存中,无论来自操作的峰值是否将大量的不经常访问数据带入缓冲池.</li>
<li>你可以控制何时以及如何执行预读请求以异步读取预期很快就会需要的页面进入缓冲池.</li>
<li>你可以控制何时进行后台刷新操作以及是否根据工作负载动态调整刷新率.</li>
<li>你可以微调缓冲池刷新行为的各个方面以提高性能.</li>
<li>你可以配置InnoDB如何保留当前缓冲池状态,以避免服务器重新启动后的长时间预热.</li>
</ul>
<p><strong>使用InnoDB标准监视器监控缓冲池</strong></p>
<p>使用<code>SHOW ENGINE INNODB STATUS</code>可以获取InnoDB标准监视器输出,缓冲池相关的信息在<code>BUFFER POOL AND MEMORY</code>部分:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 2198863872</span><br><span class="line">Dictionary memory allocated 776332</span><br><span class="line">Buffer pool size   131072</span><br><span class="line">Free buffers       124908Database pages     5720</span><br><span class="line">Old database pages 2071</span><br><span class="line">Modified db pages  910</span><br><span class="line">Pending reads 0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 4, not young 00.10 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 197, created 5523, written 50600.00 reads/s, 190.89 creates/s, 244.94 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read</span><br><span class="line">ahead 0.00/s</span><br><span class="line">LRU len: 5720, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure>

<p>缓冲池各项指标对照表:</p>
<p><img src="https://i.loli.net/2019/02/14/5c653037ec928.png"> </p>
<h4 id="14-5-2-变更缓存区-Change-Buffer"><a href="#14-5-2-变更缓存区-Change-Buffer" class="headerlink" title="14.5.2 变更缓存区(Change Buffer)"></a>14.5.2 变更缓存区(Change Buffer)</h4><p>变更缓存区是一个特殊的数据结构,当页面不在缓冲池里的时候它会缓存对这些页面二级索引的变更.缓存的变化可能是由于insert,update,delete操作(DML)引起的,在这些页面被其他读操作加载到缓冲池的时候会合并这些改变.</p>
<p>变更缓存区结构:</p>
<p><img src="https://dev.mysql.com/doc/refman/5.7/en/images/innodb-change-buffer.png"></p>
<p>不像聚簇索引,二级索引通常不是唯一的,并且二级索引的插入顺序是相对随机的.同样,删除和更新可能会影响不在索引树中的相邻的二级索引页.变更缓存区的合并会被延迟到受影响的页面被其他操作读取到缓冲池的时候进行,避免从磁盘读取二级索引页面到缓冲池所需的大量随机访问I&#x2F;O.</p>
<p>清除操作会在系统空闲或者缓慢关机的时候定期地把更新过的索引页写到磁盘上.在此期间,磁盘I&#x2F;O会增加,可能会导致和磁盘相关的查询速度显著下降.缓存区变更的合并在事务被提交之后可能会继续发生,甚至在服务器关闭和重启的时候.</p>
<p>在内存里,变更缓存区拥有一部分缓冲池.在磁盘上,变更缓存区是系统表空间的一部分,当数据库服务关闭的时候被缓存的索引会变更.</p>
<p><code>innodb_change_buffering</code>变量管理变更缓存区缓存的数据类型.</p>
<p>如果索引包含降序的索引列或者主键包含递减索引列的话二级索引就不支持变更缓存区.</p>
<p><strong>变更缓存区的配置</strong></p>
<p>当在表上执行insert,update和delete的时候,索引列的值(尤其是二级索引的值)通常是未排序的,需要大量的I&#x2F;O才能更新二级索引.当相关页面不在缓冲池里的时候变更缓存区会改变二级索引的条目,以此来避免立即从磁盘上读取页面的大量的I&#x2F;O操作消耗.当页面加载到缓冲池的时候,缓存的变更会被合并,然后被更新的页面会随后刷新到磁盘.InnoDB主线程会在服务器空闲以及慢关机(slow shutdown)期间合并缓存的变更.</p>
<p>由于可以减少磁盘的读写次数,变更缓存区功能对于I&#x2F;O绑定的工作最有价值.例如有批量插入这样的大量的DML操作的应用.</p>
<p>然而,变更缓存区占据了一部分的缓冲池空间,减少了可以用来缓存数据页面的内存.如果工作完全适合于缓冲池或者你的表里二级索引很少,关闭变更缓存区可能更有用.如果工作中的数据集(的大小)完全适合缓冲池,变更缓存区不会增加额外的开销,因为它只适用于不在缓冲池的页面.</p>
<p>你可以使用<code>innodb_change_buffering</code>参数来控制InnoDB对变更缓存区的处理.你可以打开或关闭对插入,删除操作和清除操作的缓存.更新操作被分解为插入和删除操作.默认的<code>innodb_change_buffering</code>值是<em>all</em>.</p>
<p>合法的<code>innodb_change_buffering</code>参数如下:</p>
<ul>
<li>all<br>默认值:缓存插入,标记删除操作和清除(purges)</li>
<li>none<br>不缓存任何操作</li>
<li>inserts<br>缓存插入操作</li>
<li>deletes<br>缓存标记删除操作</li>
<li>changes<br>缓存插入和标记删除</li>
<li>purges<br>缓存发生在后台的物理删除操作</li>
</ul>
<p>通过MySQL配置文件(<em>my.cnf</em> 或<em>my.ini</em>)的<code>innodb_change_buffering</code>参数或者<code>SET GLOBAL</code>语句设置(需要权限).更改设置只会影响新的缓冲,现有的缓冲数据不受影响.</p>
<p><strong>设置变更缓存区的最大大小</strong></p>
<p><code>innodb_change_buffer_max_size</code>变量可以设置变更缓存区占缓冲池的百分比大小.默认<code>innodb_change_buffer_max_size</code>是25,最大可以设置50.</p>
<p>考虑增加<code>innodb_change_buffer_max_size</code>如果服务器有大量的insert,update和delete操作.</p>
<p>考虑减少<code>innodb_change_buffer_max_size</code>如果服务器使用静态数据来做报告.</p>
<p>在典型的工作负载下测试不同的设置来决定使用哪一个配置.<code>innodb_change_buffer_max_size</code>可以在不重启服务器的情况下动态修改.</p>
<p><strong>监控变更缓存区</strong></p>
<ul>
<li>标准监视器:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>

<p>信息如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0Hash table size 4425293, used cells 32, node heap has 1 buffer(s)13577.57 hash searches/s, 202.47 non-hash searches/s</span><br></pre></td></tr></table></figure>

<ul>
<li><code>INFORMATION_SCHEMA.INNODB_METRICS</code>表里提供了InnoDB标准监视器里的大部分数据,还有额外的数据.使用下面的sql查看变更缓存区的指标:<blockquote>
<p><code>mysql&gt; SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME LIKE &#39;%ibuf%&#39;\G</code></p>
</blockquote>
</li>
<li><code>INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code>提供了缓冲池里每个页面的元数据,包括变更缓存区索引和变更缓存区位图页面.变更缓存区由<code>PAGE_TYPE</code>标识,<code>IBUF_INDEX</code>是变更缓存区索引页面的页面类型,<code>IBUF_BITMAP</code>是变更缓存区位图页的页面类型.</li>
</ul>
<blockquote>
<p><strong>警告:</strong><br>查询<code>INNODB_BUFFER_PAGE</code>表会带来显著的性能损耗.为了避免性能影响,请在测试实例上运行查询和排除问题.<br>例如,你可以查询<code>INNODB_BUFFER_PAGE</code>表来决定<code>IBUF_INDEX</code>和<code>IBUF_BITMAP</code>页面占总缓冲池页的百分比.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</span><br><span class="line">       WHERE PAGE_TYPE LIKE &#x27;IBUF%&#x27;) AS change_buffer_pages, </span><br><span class="line">       (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE) AS total_pages,</span><br><span class="line">       (SELECT ((change_buffer_pages/total_pages)*100)) </span><br><span class="line">       AS change_buffer_page_percentage;</span><br><span class="line">+---------------------+-------------+-------------------------------+</span><br><span class="line">| change_buffer_pages | total_pages | change_buffer_page_percentage |</span><br><span class="line">+---------------------+-------------+-------------------------------+</span><br><span class="line">|                  25 |        8192 |                        0.3052 |</span><br><span class="line">+---------------------+-------------+-------------------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>性能概要(Performance Schema)提供变更缓存区互斥等待监控表进行高级性能监控.使用下面的查询:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> performance_schema.setup_instruments</span><br><span class="line">       <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%wait/synch/mutex/innodb/ibuf%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> NAME                                                  <span class="operator">|</span> ENABLED <span class="operator">|</span> TIMED <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> wait<span class="operator">/</span>synch<span class="operator">/</span>mutex<span class="operator">/</span>innodb<span class="operator">/</span>ibuf_bitmap_mutex             <span class="operator">|</span> YES     <span class="operator">|</span> YES   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> wait<span class="operator">/</span>synch<span class="operator">/</span>mutex<span class="operator">/</span>innodb<span class="operator">/</span>ibuf_mutex                    <span class="operator">|</span> YES     <span class="operator">|</span> YES   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> wait<span class="operator">/</span>synch<span class="operator">/</span>mutex<span class="operator">/</span>innodb<span class="operator">/</span>ibuf_pessimistic_insert_mutex <span class="operator">|</span> YES     <span class="operator">|</span> YES   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------+---------+-------+</span></span><br></pre></td></tr></table></figure>

<h4 id="14-5-3-自适应哈希索引-Adaptive-Hash-Index"><a href="#14-5-3-自适应哈希索引-Adaptive-Hash-Index" class="headerlink" title="14.5.3 自适应哈希索引(Adaptive Hash Index)"></a>14.5.3 自适应哈希索引(Adaptive Hash Index)</h4><p>自适应哈希索引特性使得InnoDB在合适的工作负载和提供给缓冲池(buffer pool)足够的内存的情况下表现的更像一个内存型数据库并且不会损失事务特性和可靠性.自适应哈希索引特性由<code> innodb_adaptive_hash_index</code>变量来控制,或者是在启动服务器时加上<code>--skip-innodb-adaptive-hash-index</code>.</p>
<p>根据观察到的搜索模式,使用索引键(index key)的前缀来构建哈希索引.前缀可以是任意长的,并且有可能只是B树中的一些值出现在哈希索引里.哈希索引是根据需要经常访问的页面索引构建的.</p>
<p>如果一张表几乎全部进入主存,哈希索引可以通过允许直接查找任何元素来加速,把索引的值转换为一种指针.InnoDB有一种监控索引搜索的机制.如果InnoDB注意到查询可以从构建哈希索引中受益就会自动进行(这个过程).</p>
<p>对于一些工作来说,从哈希索引获得的加速远远超过了监控索引查找和维护一个哈希索引结构的速度.在高工作负载下,对自适应哈希索引的访问有时会变成资源竞争的来源,例如多个连接的joins.LIKE操作和%符号的查询也不会受益.对于不能从自适应哈希索引中获益的工作,关闭以减少不必要的性能消耗.因为很难预测对一个特定的系统来说自适应哈希索引特性是否有用,考虑使用基准测试来比较开启和不开启的性能差距.MySQL5.6的架构变化使其更适于禁用自适应哈希索引相比于更早的版本来说.</p>
<p>在MySQL5.7中,自适应哈希索引特性是分区的.每一个索引绑定到一个特定的分区,每一个分区都由一个锁存器来保护.分区由<code>innodb_adaptive_hash_index_parts</code>来控制.在早期版本中,自适应哈希索引由一个锁存器来保护,这可能会成为高负载下的一个竞争点.<code>innodb_adaptive_hash_index_parts</code>默认值是8,最大可以设置512.</p>
<p>可以通过<code>SHOW ENGINE INNODB STATUS</code>的<code>SEMAPHORES</code>部分来监控自适应哈希索引.如果有大量的线程在等待<em>btr0sea.c</em>创建RW-latches,考虑增大自适应哈希索引分区的数量或者关闭自适应哈希索引特性.</p>
<h4 id="日志缓冲区-Log-Buffer"><a href="#日志缓冲区-Log-Buffer" class="headerlink" title="日志缓冲区(Log Buffer)"></a>日志缓冲区(Log Buffer)</h4><p>日志缓冲区是保存要写到磁盘上的日志文件的区域.日志缓冲区的大小由<code>innodb_log_buffer_size</code>定义.默认的大小是16MB.日志缓冲区的内容会定期刷新到磁盘上.一个大的日志缓冲区使大型的事务可以运行而无需在事务提交之前把重做日志(redo log)的数据写到磁盘上.因此,如果你有事务更新,插入或删除很多行的话,增大日志缓冲区来节省磁盘I&#x2F;O.</p>
<p><code>innodb_flush_log_at_trx_commit</code>变量控制日志缓冲区的内容如何写入和刷新到磁盘.<code>innodb_flush_log_at_timeout</code>控制日志刷新的频率.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/15/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/17/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">MisakaTang</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/TangMisaka23001" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","mhchem":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
