<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"misakatang.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"style":null,"show_result":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="The limits of my language are the limits of my world">
<meta property="og:type" content="website">
<meta property="og:title" content="MisakaTang&#39;s Blog">
<meta property="og:url" content="http://misakatang.cn/page/14/index.html">
<meta property="og:site_name" content="MisakaTang&#39;s Blog">
<meta property="og:description" content="The limits of my language are the limits of my world">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="MisakaTang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://misakatang.cn/page/14/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/14/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MisakaTang's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4TSLH4NC9H"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-4TSLH4NC9H","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?de7c77febeeac252eee468207ae11ce4"></script>



  <script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "jtb4czrfeu");
</script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="MisakaTang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">MisakaTang's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MisakaTang"
      src="/images/misaka.jpg">
  <p class="site-author-name" itemprop="name">MisakaTang</p>
  <div class="site-description" itemprop="description">The limits of my language are the limits of my world</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/%E5%BD%92%E6%A1%A3/">
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/TangMisaka23001" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TangMisaka23001" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mikasatang@gmail.com" title="E-Mail → mailto:mikasatang@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="http://blog.bbchen.top/" title="http:&#x2F;&#x2F;blog.bbchen.top" rel="noopener" target="_blank">BB chen的漂流记</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://blog.zhuzhenyuan.cn/" title="http:&#x2F;&#x2F;blog.zhuzhenyuan.cn" rel="noopener" target="_blank">Aurthur_的博客</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://misakatang.cn/2019/09/02/InnoDB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-14-7-2-InnoDB%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B-14-7-3-InnoDB%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8CSQL%E8%AF%AD%E5%8F%A5%E8%AE%BE%E7%BD%AE%E7%9A%84%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/misaka.jpg">
      <meta itemprop="name" content="MisakaTang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MisakaTang's Blog">
      <meta itemprop="description" content="The limits of my language are the limits of my world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | MisakaTang's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/02/InnoDB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-14-7-2-InnoDB%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B-14-7-3-InnoDB%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8CSQL%E8%AF%AD%E5%8F%A5%E8%AE%BE%E7%BD%AE%E7%9A%84%E9%94%81/" class="post-title-link" itemprop="url">InnoDB官方文档--14.7.2 InnoDB事务模型|14.7.3 InnoDB中的不同SQL语句设置的锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-02 12:01:22" itemprop="dateCreated datePublished" datetime="2019-09-02T12:01:22+00:00">2019-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-14 08:33:24" itemprop="dateModified" datetime="2024-03-14T08:33:24+00:00">2024-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="14-7-2-InnoDB事务模型"><a href="#14-7-2-InnoDB事务模型" class="headerlink" title="14.7.2 InnoDB事务模型"></a>14.7.2 InnoDB事务模型</h4><p>在InnoDB事务模型里,其目标就是把多版本数据库的最佳属性和传统的两段锁相结合.InnoDB在行级进行加锁并且默认情况下将查询作为非锁定的一致性读取来运行,这是Oracle的风格.InnoDB中的锁信息是高效存储的所以不需要升级.通常允许多个用户锁定InnoDB表中的每一行,或行的任何随机子集而不会导致InnoDB内存耗尽.</p>
<h5 id="14-7-2-1-事务隔离级别"><a href="#14-7-2-1-事务隔离级别" class="headerlink" title="14.7.2.1 事务隔离级别"></a>14.7.2.1 事务隔离级别</h5><p>事务隔离是数据库处理的基础之一.隔离(Isolation)是ACID中I的缩写;隔离级别是在多个事务同时进行更改和执行查询时对性能和可靠性,一致性和结果的可重复性进行平衡的细微调整的设置.</p>
<p>InnoDB提供SQL:1992标准描述的四种事务隔离级别:<code> READ UNCOMMITTED</code>,<code> READ COMMITTED</code>,<code> REPEATABLE READ</code>和<code> SERIALIZABLE</code>.InnoDB默认的事务隔离级别是<code> REPEATABLE READ</code>.</p>
<p>用户可以改变单个会话(session)的隔离级别或使用<code>SET TRANSACTION</code>语句为连接后面所有的语句设置.为了对所有的连接设置服务器默认的隔离级别,在命令行使用<code> --transaction-isolation</code>选项或在配置文件中.</p>
<p>InnoDB支持对每个事务隔离级别使用不同的锁策略.你可以对符合ACID规范很重要的关键数据的操作使用默认的<code>REPEATABLE READ</code>级别来强制执行高一致性.或者你可以使用<code> READ COMMITTED</code>或<code> READ UNCOMMITTED</code>放松一致性要求,在例如批量报告等情况下,精确的一致性和可重复结果不如最小化锁的开销那么重要.<code> SERIALIZABLE</code>比<code> REPEATABLE READ</code>更严格,且主要用于特殊情况,例如XA事务以及并发和死锁的故障问题排除上.</p>
<p>下面列出了MySQL支持的不同事务隔离级别.排列顺序由最常使用到不经常使用:.</p>
<ul>
<li><p>REPEATABLE READ(可重复读)</p>
<p>这是InnoDB默认的隔离级别.同一事务中的一致读读取第一次读取建立的快照.这意味着如果在同一事务中发出几个普通(非锁定)SELECT语句,这些SELECT语句也相互一致.</p>
<p>对加锁读(<code>SELECT ... FOR UPDATE</code>或<code>SELECT ... LOCK IN SHARE MODE</code>),UPDATE和DELETE语句,根据是否语句使用了有唯一搜索条件的唯一索引或范围类型搜索条件.</p>
<ul>
<li>对使用唯一索引的唯一搜索条件,InnoDB只对找到的索引记录加锁,不对之前的间隙加锁.</li>
<li>对其他搜索条件,InnoDB对扫描到的索引范围加锁,使用间隙锁或next-key锁来阻止其他会话插入覆盖的范围的间隙.</li>
</ul>
</li>
<li><p>READ COMMITTED(已提交读)</p>
<p>即使在同一事务中,每个一致的读取也会设置和读取自己的新快照.</p>
<p>对加锁读(<code>SELECT ... FOR UPDATE</code>或<code>SELECT ... LOCK IN SHARE MODE</code>),UPDATE和DELETE语句,InnoDB只锁定索引记录而不是之前的间隙,因此允许在锁定的记录边上自由插入新记录.间隙锁只用于外键约束检查和重复键检查.</p>
<p>因为间隙锁被禁用,可能会引起幻读问题,因为其他会话可以在间隙中插入新的行.</p>
<p>只有基于行的二进制日志(row-based logging)支持READ COMMITTED隔离级别.如果你在<code> binlog_format=MIXED</code>时使用READ COMMITTED,服务器会自动使用基于行的日志.</p>
<p>使用READ COMMITTED还有其他影响:</p>
<ul>
<li>对UPDATE和DELETE语句,InnoDB只对update或delete的行保持锁.MySQL评估WHERE条件后,将释放不匹配行的记录锁.这大大降低了死锁的可能性,但仍然可能发生.</li>
<li>对UPDATE语句,如果行已经被加锁,InnoDB会执行”半一致性”读,将最新提交的版本返回给MySQL,以便MySQL可以确定该行是否与UPDATE的WHERE条件匹配. 如果行匹配(必须更新),MySQL再次读取该行,这次InnoDB将其锁定或等待锁定.</li>
</ul>
<p>考虑下面的例子,从这个表开始:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (a <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, b <span class="type">INT</span>) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">2</span>),(<span class="number">4</span>,<span class="number">3</span>),(<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>在这个情况下,表没有索引所以搜索和索引扫描使用隐藏的聚簇索引进行记录加锁而不是被索引的列.</p>
<p>假设一个会话使用下面的语句执行了一个UPDATE:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Session A</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> b <span class="operator">=</span> <span class="number">5</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>假设第二个会话在第一个会话之后执行UPDATE语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Session B</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> b <span class="operator">=</span> <span class="number">4</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>当InnoDB执行每个UPDATE时,首先对读取的每一行获取一个独占锁,然后来决定是否修改.如果InnoDB没有修改行就会释放锁.换句话说,InnoDB会持有这些锁直到事务结束.对事务处理的影响如下.</p>
<p>当使用默认的REPEATABLE READ隔离级别时,第一个UPDATE需要对读取的每一行加独占锁(X-lock)并且不释放任何一个:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x-lock(1,2); retain x-lock</span><br><span class="line">x-lock(2,3); update(2,3) to (2,5); retain x-lock</span><br><span class="line">x-lock(3,2); retain x-lock</span><br><span class="line">x-lock(4,3); update(4,3) to (4,5); retain x-lock</span><br><span class="line">x-lock(5,2); retain x-lock</span><br></pre></td></tr></table></figure>
<p>第二个UPDATE在尝试获取任何锁时会立刻阻塞(因为第一个update对所有行持有锁),并且在第一个UPDATE提交或回滚之前不会继续执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x-lock(1,2); block and wait for first UPDATE to commit or roll back</span><br></pre></td></tr></table></figure>
<p>如果改为使用READ COMMITTED,第一个UPDATE会对读取的每一行加独占锁(x-lock)并且释放不需要修改的行的锁:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x-lock(1,2); unlock(1,2)</span><br><span class="line">x-lock(2,3); update(2,3) to (2,5); retain x-lock</span><br><span class="line">x-lock(3,2); unlock(3,2)</span><br><span class="line">x-lock(4,3); update(4,3) to (4,5); retain x-lock</span><br><span class="line">x-lock(5,2); unlock(5,2)</span><br></pre></td></tr></table></figure>
<p>对第二个UPDATE,InnoDB进行”半一致性”读,返回它读取到MySQL的每一行的最新提交版本,以便MySQL可以确定该行是否与UPDATE的WHERE条件匹配:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x-lock(1,2); update(1,2) to (1,4); retain x-lock</span><br><span class="line">x-lock(2,3); unlock(2,3)</span><br><span class="line">x-lock(3,2); update(3,2) to (3,4); retain x-lock</span><br><span class="line">x-lock(4,3); unlock(4,3)</span><br><span class="line">x-lock(5,2); update(5,2) to (5,4); retain x-lock</span><br></pre></td></tr></table></figure>
<p>然而,如果WHERE条件包含被索引的列并且InnoDB使用索引列,在获取和保留记录锁的时候只有被索引的列会被考虑.在下面的例子里,第一个UPDATE获取和保留了b&#x3D;2的所有行的独占锁(x-lock).第二个UPDATE在尝试获取相同记录的独占锁时阻塞,因为其也使用了在b列上定义的索引.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (a <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, b <span class="type">INT</span>, c <span class="type">INT</span>, INDEX (b)) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"># Session A</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> b <span class="operator">=</span> <span class="number">3</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"># Session B</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> b <span class="operator">=</span> <span class="number">4</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>使用READ COMMITTED隔离级别的效果与启用不推荐使用的<code>innodb_locks_unsafe_for_binlog</code>配置选项相同,但有以下例外:</p>
<ul>
<li>启用<code>innodb_locks_unsafe_for_binlog</code>是一个全局设置并影响所有会话,而隔离级别可以为所有会话全局设置,也可以为每个会话单独设置.</li>
<li><code>innodb_locks_unsafe_for_binlog</code>只能在服务器启动时设置,而隔离级别可以在启动时设置或在运行时更改.</li>
</ul>
</li>
<li><p>READ UNCOMMITTED(未提交读)</p>
<p>SELECT语句以非锁定方式执行,但可能使用行的早期版本.因此,使用此隔离级别读取可能不一致.这也被称为脏读.除了这点之外,此隔离级别与READ COMMITTED类似.</p>
</li>
<li><p>SERIALIZABLE(可串行化)</p>
<p>这个级别就像REPEATABLE READ,但InnoDB隐式地将所有普通SELECT语句转换为<code>SELECT ... LOCK IN SHARE MODE</code>如果禁用自动提交(autocommit).如果启用了自动提交,则每个SELECT都是事务.因此,已知它是只读的,并且如果作为一致(非锁定)读取执行则可以序列化,并且不需要阻止其他事务.(要强制普通SELECT阻止其他事务已修改所选行,请禁用自动提交.)</p>
</li>
</ul>
<h5 id="14-7-2-2-自动提交-提交和回滚"><a href="#14-7-2-2-自动提交-提交和回滚" class="headerlink" title="14.7.2.2 自动提交,提交和回滚"></a>14.7.2.2 自动提交,提交和回滚</h5><p>在InnoDB中,所有用户活动都发生在事务里.如果启用自动提交,每个SQL语句自己形成一个事务.默认情况下,MySQL为每个新的连接开启一个启用自动提交的会话,所以如果语句执行没有返回错误的话,MySQL会在每个SQL后执行一个提交(commit).如果语句返回错误,根据错误信息会进行提交或者回滚.</p>
<p>启用了自动提交的事务可以使用以<code> START TRANSACTION</code>或<code> BEGIN</code>开始,以<code>COMMIT</code>或<code>ROLLBACK</code>结束的语句来显式执行多语句的事务.</p>
<p>如果在一个会话中<code>SET autocommit = 0</code>来禁用自动提交的话,会话会始终打开一个事务.<code>COMMIT</code>或<code>ROLLBACK</code>语句结束当前的事务然后会打开一个新的.</p>
<p>如果禁用自动提交的事务没有显式的提交来结束事务的话,MySQL会回滚改事务.</p>
<p>某些语句会隐式的结束一个事务,就像你在执行完语句之前执行了一个<code>COMMIT</code>一样.</p>
<p>COMMIT表示当前事务中所做的更改是永久性的,并且对其他会话可见.另一方面,ROLLBACK语句取消当前事务所做的所有修改.COMMIT和ROLLBACK都释放在当前事务期间设置的所有InnoDB锁.</p>
<p><strong>使用事务对DML操作分组(Grouping DML Operations with Transactions)</strong></p>
<p>默认情况下,与MySQL服务器的连接始于启用自动提交模式,该模式会在你执行时自动提交每个SQL语句.如果你有其他数据库系统的经验,可能不熟悉此操作模式,其中标准做法是发出一系列DML语句并将它们提交或一起回滚.</p>
<p>为了使用多语句事务,使用SQL语句<code>SET autocommit = 0</code>关闭自动提交并且每个事务都以COMMIT或ROLLBACK结束.要启用自动提交,使用START TRANSACTION开始每个事务,使用COMMIT或ROLLBACK结束.下面的例子展示了两个事务.第一个被提交,第二个回滚了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; mysql test</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (a <span class="type">INT</span>, b <span class="type">CHAR</span> (<span class="number">20</span>), INDEX (a));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="comment">-- Do a transaction with autocommit turned on.</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> customer <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">&#x27;Heikki&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">COMMIT</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="comment">-- Do another transaction with autocommit turned off.</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> customer <span class="keyword">VALUES</span> (<span class="number">15</span>, <span class="string">&#x27;John&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> customer <span class="keyword">VALUES</span> (<span class="number">20</span>, <span class="string">&#x27;Paul&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> customer <span class="keyword">WHERE</span> b <span class="operator">=</span> <span class="string">&#x27;Heikki&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="comment">-- Now we undo those last 2 inserts and the delete.</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+</span></span><br><span class="line"><span class="operator">|</span> a    <span class="operator">|</span> b      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span> Heikki <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>客户端语言中的事务(Transactions in Client-Side Languages)</strong></p>
<p>在例如PHP,Perl DBI,JDBC,ODBC或其他MySQL标准C调用接口,你可以将事务控制语句(如COMMIT)作为字符串发送到MySQL服务器,就像任何其他SQL语句(如SELECT或INSERT)一样.某些API还提供单独的特殊事务提交和回滚功能或方法.</p>
<h5 id="14-7-2-3-一致性非锁定读-Consistent-Nonlocking-Reads"><a href="#14-7-2-3-一致性非锁定读-Consistent-Nonlocking-Reads" class="headerlink" title="14.7.2.3 一致性非锁定读(Consistent Nonlocking Reads)"></a>14.7.2.3 一致性非锁定读(Consistent Nonlocking Reads)</h5><p>一致性读意味着InnoDB使用多版本控制(multi-versioning)在某个时间点向查询提供数据库的快照.查询将查看在该时间点之前提交的事务所做的更改,并且不会对以后或未提交的事务所做的更改进行更改.此规则的例外是查询会查看同一事务中更早提交的语句所做的更改.这个例外会导致下面的问题:如果你更新了表中的某些行,一个<code>SELECT</code>会查看最近更新的行,但它也可能查找到任何行的旧版本.如果其他会话同时更新相同的表,问题出现在你可能会看到一个从没在数据库中存在过的该表的状态.</p>
<p>如果事务的隔离级别是REPEATABLE READ(默认配置),同一事务中的所有一致性读都读取该事务第一次创建的快照.你可以在执行了新的查询之后提交该事务来获得一个更新的快照.</p>
<p>在READ COMMITTED隔离级别下,事务的每个一致性读都读取其自己的新快照.</p>
<p>一致性读是InnoDB的<code> READ COMMITTED</code>和<code> REPEATABLE READ</code>隔离级别默认的SELECT语句的处理模式.一致性读不在访问的表上设置任何锁,因此其他会话可以在一致性读在表上执行的同时自由地修改这些表.</p>
<p>假设你运行在默认的 REPEATABLE READ事务隔离级别下.当你发起一个一致性读(也就是普通的SELECT语句)的时候,InnoDB给你一个事务的时间点,根据这个时间点来查询你要查看的数据库.如果其他事务在你被授予的时间点之后删除了一行数据然后提交的话,你是不会看见这行数据被删除的.INSERT和UPDATE也是相似的.</p>
<p>你可以通过提交事务来更新你的时间点然后进行新的<code>SELETE</code>或<code> START TRANSACTION WITH CONSISTENT SNAPSHOT</code>.</p>
<p>这被称为多版本并发控制(multi-versioned concurrency control).</p>
<p>在下面的例子里,会话A只有在B提交了insert数据并且A自己也进行了提交之后才能看到B插入的数据(因为时间节点更新到了B提交之后).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">             Session A              Session B</span><br><span class="line"></span><br><span class="line">           SET autocommit=0;      SET autocommit=0;</span><br><span class="line">time</span><br><span class="line">|          SELECT * FROM t;</span><br><span class="line">|          empty set</span><br><span class="line">|                                 INSERT INTO t VALUES (1, 2);</span><br><span class="line">|</span><br><span class="line">v          SELECT * FROM t;</span><br><span class="line">           empty set</span><br><span class="line">                                  COMMIT;</span><br><span class="line"></span><br><span class="line">           SELECT * FROM t;</span><br><span class="line">           empty set</span><br><span class="line"></span><br><span class="line">           COMMIT;</span><br><span class="line"></span><br><span class="line">           SELECT * FROM t;</span><br><span class="line">           ---------------------</span><br><span class="line">           |    1    |    2    |</span><br><span class="line">           ---------------------</span><br></pre></td></tr></table></figure>
<p>如果你想始终查看”最新鲜”的数据库,使用<code> READ COMMITTED</code>事务隔离级别或者加锁读:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">FOR</span> SHARE;</span><br></pre></td></tr></table></figure>
<p>在READ COMMITTED隔离级别下,一个事务下的每个一致性读都会设置和读取自己最新的快照.使用<code>LOCK IN SHARE MODE</code>会发生加锁读:SELECT会阻塞直到包含有最新行的事务结束(才执行).</p>
<p>一致性读对某些DDL语句不起作用:</p>
<ul>
<li>一致性读对<code>DROP TABLE</code>不起作用,因为MySQL不能使用已被删除的表而且InnoDB会破坏该表.</li>
<li>一致性读对<code>ALTER TABLE</code>不起作用,因为这个语句会制作一个原表的临时拷贝然后在临时拷贝构建之后删除原表.当在事务中重新发出一致读时,新表中的行不可见,因为在执行事务快照时这些行不存在.在这种情况下,事务会返回一个错误: ER_TABLE_DEF_CHANGED,”表定义被修改,请重试事务”.</li>
</ul>
<p>不指定<code>FOR UPDATE</code>或<code>LOCK IN SHARE MODE</code>的select的读取类型因<code>INSERT INTO ... SELECT</code>,<code>UPDATE ...(SELECT)</code>和<code>CREATE TABLE ... SELECT</code>等子句中的选择而异.</p>
<ul>
<li>默认情况下,InnoDB使用更强的锁(粒度更大),SELECT部分​​的作用类似于READ COMMITTED,即使在同一事务中,每个一致的读取也会设置和读取自己的新快照.</li>
<li>要在这种情况下使用一致的读取,启用<code>innodb_locks_unsafe_for_binlog</code>选项并将事务的隔离级别设置为READ UNCOMMITTED,READ COMMITTED或REPEATABLE READ.在这种情况下,不会对从所选表中读取的行设置锁.</li>
</ul>
<h5 id="14-7-2-4-加锁读-Locking-Reads"><a href="#14-7-2-4-加锁读-Locking-Reads" class="headerlink" title="14.7.2.4 加锁读(Locking Reads)"></a>14.7.2.4 加锁读(Locking Reads)</h5><p>如果你在同一个事务里查询数据然后插入或更新相关的数据,常规SELECT语句没有提供足够的保护.其他事务可以更新或删除你刚刚查询的行.InnoDB支持两种类型的加锁读来提供额外的安全性:</p>
<ul>
<li><p>SELECT … LOCK IN SHARE MODE</p>
<p>在读取的所有行上设置一个共享模式锁.其他会话可以读取这些行,但是直到你的事务提交之前都不能修改它们.如果这些行中的任何一行被其他没有提交的事务修改的话,你的查询会等到这些事务结束然后使用最新的值.</p>
</li>
<li><p>SELECT … FOR UPDATE</p>
<p>对于搜索遇到的索引记录,锁定行和任何关联的索引条目,就像对这些行使用UPDATE语句一样.其他事务更新这些行会被阻塞,从<code>SELECT ... LOCK IN SHARE MODE</code>,或从某些事务隔离级别读取数据.一致性读取将忽略在读取视图中存在的记录上设置的任何锁.(无法锁定旧版本的记录;它们通过在记录的内存中副本上应用撤消日志来重建).</p>
</li>
</ul>
<p>这些子句在处理树形结构或图形结构数据时非常有用,无论是在单个表中还是在多个表中分割.你将边缘或树的分支从一个地方遍历到另一个地方,同时保留返回的权限并更改任何这些”指针”值.</p>
<p>在提交或回滚事务时,将释放由LOCK IN SHARE MODE和FOR UPDATE查询设置的所有锁.</p>
<p>外部语句中的锁定读取子句不会锁定嵌套子查询中的表行,除非在子查询中也指定了锁定读取子句.例如,以下语句不会锁定表t2中的行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE;</span><br></pre></td></tr></table></figure>
<p>要锁定表t2中的行,请在子查询中添加一个锁定读取子句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p><strong>加锁读的例子</strong></p>
<p>假设你想要插入一个新行到子表中,确认对应的子表行在父表中有父行.你的应用程序代码可确保整个操作序列中的引用完整性.</p>
<p>首先,使用一个一致性读查询父表并且确认父表中的行存在.你可以将子行安全的插入到子表吗?不,因为其他会话可以在你的SELECT和INSERT语句之间删除父表中的行而你不会意识到.</p>
<p>为了避免上面的问题,使用<code>LOCK IN SHARE MODE</code>来执行SELECT:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> parent <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;Jones&#x27;</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>
<p>在LOCK IN SHARE MODE查询返回父表数据’Jones’之后,你可以安全的添加子记录到子表中然后提交事务.尝试获取父表中适用行的独占锁的任何事务都会等到完成后,即直到所有表中的数据都处于一致状态.</p>
<p>对另一个例子,考虑表CHILD_CODES中的一个整数计数字段,用于为添加到CHILD表中的数据分配唯一标识符.不要使用一致读取或共享模式读取来读取计数器的当前值,因为数据库的两个用户可以看到计数器的相同值,如果两个事务尝试将具有相同标识符的行添加到CHILD表,则会发生重复键错误.</p>
<p>在这里 LOCK IN SHARE MODE不是一个好的解决方法因为如果两个用户同时读取计数器,当它尝试更新计数器时,至少有一个用户会死锁.</p>
<p>要实现读取和递增计数器,首先使用FOR UPDATE执行计数器的锁定读取,然后递增计数器.例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> counter_field <span class="keyword">FROM</span> child_codes <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> child_codes <span class="keyword">SET</span> counter_field <span class="operator">=</span> counter_field <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>SELECT ... FOR UPDATE</code>读取最新的可用数据,在其读取的每一行上设置独占锁.因此,它设置搜索的SQL UPDATE将在行上设置的相同锁.</p>
<p>前面的描述仅仅是<code>SELECT ... FOR UPDATE</code>如何工作的一个例子.在MySQL中,生成唯一标识符的具体任务实际上只需对表进行一次访问即可完成:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> child_codes <span class="keyword">SET</span> counter_field <span class="operator">=</span> LAST_INSERT_ID(counter_field <span class="operator">+</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> LAST_INSERT_ID();</span><br></pre></td></tr></table></figure>
<p>SELECT语句仅检索标识符信息(特定于当前连接).它不访问任何表.</p>
<h4 id="14-7-3-InnoDB中的不同SQL语句设置的锁"><a href="#14-7-3-InnoDB中的不同SQL语句设置的锁" class="headerlink" title="14.7.3 InnoDB中的不同SQL语句设置的锁"></a>14.7.3 InnoDB中的不同SQL语句设置的锁</h4><p>加锁读,UPDATE或DELETE会在正在处理的SQL语句中被扫描到的每个索引记录上设置锁.这跟WHERE子句中是否会排除行数据无关.InnoDB不会记住精确的WHERE语句,(它)只知道索引要扫描的范围.锁通常是next-key锁同时也会阻止插入到记录之前的间隙(gap)中.然而间隙锁可以被显式禁用,这会导致next-key锁不被使用.</p>
<p>如果在搜索中使用了二级索引并且索引记录被设置为独占,InnoDB也会检索相应的聚簇索引并且对其加锁.</p>
<p>如果对你的语句没有合适的索引,MySQL必须扫描整张表来处理语句,表中的每一行都会被加锁,这会使得其他用户对这张表的insert操作全部阻塞.创建一个好的索引非常重要,这样你的查询就不会扫描到很多不必要的行.</p>
<p>InnoDB设置特定类型的锁,如下:</p>
<ul>
<li><p><code>SELECT...FROM</code>是一个一致性读,会读取数据库的一个快照并且不会加锁,除非事务的隔离级别被设置成<code>SERIALIZABLE</code>.对<code>SERIALIZABLE</code>级别,搜索会在遇到的索引记录上设置一个共享的next-key锁.但是,对于使用唯一索引锁定行以搜索唯一行的语句,只需要索引记录锁定.</p>
</li>
<li><p>对<code>SELECT...FOR UPDATE</code>或<code>SELECT...LOCK IN SHARE MODE</code>,会对需要扫描的行加锁,并且对预计不会出现在结果集中的行释放锁(例如,如果其不符合where子句中的要求).然而,在某些情况下,行也许不会被立刻解锁因为在查询期间结果行和原始数据之间的关系可能会丢失.例如,从表中扫描(和锁定)的行可能会在评估它们是否符合结果之前插入临时表中. 在这种情况下,临时表中的行与原始表中的行的关系将丢失,并且在查询执行结束之前不会解锁后面的行.</p>
</li>
<li><p><code>SELECT...LOCK IN SHARE MODE</code>在搜索遇到的所有的索引记录上设置共享next-key锁.但是,对于使用唯一索引锁定行以搜索唯一行的语句,只需要索引记录锁定.</p>
</li>
<li><p><code>SELECT...FOR UPDATE</code>在搜索遇到的所有索引记录上设置一个独占的next-key锁.但是,对于使用唯一索引锁定行以搜索唯一行的语句,只需要索引记录锁定.</p>
<p>  对搜索遇到的索引记录,<code>SELECT...FOR UPDATE</code>会阻止其他会话执行<code>SELECT...LOCK IN SHARE MODE</code>或从其他事务隔离级别读取.一致性读取将忽略在读取视图中存在的记录上设置的任何锁定.</p>
</li>
<li><p><code>UPDATE...WHERE...</code>在搜索遇到的所有索引记录上设置独占的next-key锁.但是,对于使用唯一索引锁定行以搜索唯一行的语句,只需要索引记录锁定.</p>
</li>
<li><p>当UPDATE修改一个聚簇索引记录时,对受影响的二级索引记录采用隐式锁定.在插入新的辅助索引记录之前以及插入新的辅助索引记录时,UPDATE操纵同时也获取受影响的二级索引记录上的共享锁.</p>
</li>
<li><p><code>DELETE FROM...WHERE...</code>在搜索遇到的所有索引记录上设置独占的next-key锁.但是,对于使用唯一索引锁定行以搜索唯一行的语句,只需要索引记录锁定.</p>
</li>
<li><p>INSERT在被插入的行上设置独占锁.该锁是一个索引记录锁,不是一个next-key锁并且不会阻止其他会话插入数据到这已经插入的行之前的间隙中.</p>
<p>  在插入行之前,一个被称为插入意图锁的间隙锁被设置.此锁定表示插入的意图,即插入到相同索引间隙中的多个事务如果不插入间隙内的相同位置则不需要彼此等待.假设有索引记录4和7.分别有2个事务要向4和7之间插入5和6,这两个事务都会在获取插入行的独占锁之前对4和7之间的插入意图锁进行加锁,但是他们不会互相阻塞因为这两行是非冲突的.</p>
<p>  如果发生了重复键错误,会在重复的索引记录上设置共享锁.如果有多个会话尝试插入同一行,如果另一个会话已经具有独占锁,则使用共享锁可能导致死锁.如果另一个会话删除该行,则会发生这种情况.假设InnoDB表t1具有以下结构：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="type">INT</span>, <span class="keyword">PRIMARY</span> KEY (i)) ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure>
<p>  现在假设三个会话按顺序执行以下操作:</p>
<p>  Session1:</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  Session2:</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  Session3:</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  Session1:</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>  session1的第一个操作需要一个行的独占锁.session2和3同时引起了重复键错误并且都请求了该行的共享锁.当session1回滚的时候,会释放独占锁并且session2和3的共享锁请求会被授予.在这个时候,session2和3会死锁:无论谁都无法获取行的独占锁因为它们都持有对方的共享锁.</p>
<p>  如果表已经包含了键值为1的行然后三个会话执行下面的操作的话也会出现类似的情况:</p>
<p>  session1:</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>  session2:</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  session3:</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  session1:</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>  session1的第一个操作需要一个行的独占锁.session2和3都会引起一个重复键错误并且都请求了该行的共享锁.当session1提交的时候会释放行上的独占锁并且会授予session2和3共享锁.在这个时候session2和3会死锁:无论谁都无法获取行的独占锁因为它们都持有对方的共享锁.</p>
</li>
<li><p><code>INSERT...ON DUPLICATE KET UPDATE</code>与简单的INSERT的不同之处在于,当发生重复键错误时,在要更新的行上放置独占锁而不是共享锁.对重复的主键值采用独占索引记录锁定.对于重复的唯一键值,采用独占的下一键锁定.</p>
</li>
<li><p>如果唯一键没有冲突,REPLACE就像INSERT一样.否则,将在要替换的行上放置专用的next-key锁.</p>
</li>
<li><p><code>INSERT INTO T SELECT ... FROM S WHERE ...</code>在插入T的每一行上设置一个独占索引记录锁.如果事务隔离级别是<code>READ COMMITTED</code>或<code>innodb locks unsafe for binlog</code>启用并且事务隔离级别不是<code>SERIALIZABLE</code>,InnoDB会在s的搜索上使用一致性读.换句话说,InnoDB在从s读取的行上设置共享的next-key锁.InnoDB必须在后一种情况下设置锁定:在使用基于语句的二进制日志进行前滚恢复期间,每个SQL语句必须以与最初完成时相同的方式执行.</p>
<p>  <code>CREATE TABLE...SELECT...</code>执行带有共享next-key锁或一致性读的SELECT,类似<code>INSERT...SELECT</code>.</p>
<p>  当SELECT用来构造<code>REPLACE INTO t SELECT...FROM s WHERE ...</code> 或 <code>UPDATE t ... WHERE col IN (SELECT ... FROM s)</code>, InnoDB在表s的行上设置共享的next-key锁.</p>
</li>
<li><p>在初始化表上的先前指定的AUTO_INCREMENT列时,InnoDB在与AUTO_INCREMENT列关联的索引的末尾设置独占锁.在访问自增计数器时,InnoDB使用特定的AUTO-INC表锁定模式,其中锁定仅持续到当前SQL语句的末尾,而不是整个事务的结束.在保持AUTO-INC表锁时,其他会话无法插入表中.</p>
<p>  InnoDB在不设置任何锁定的情况下获取先前初始化的AUTO_INCREMENT列的值.</p>
</li>
<li><p>如果在表上定义了FOREIGN KEY约束,则需要检查约束条件的任何插入,更新或删除都会在其查看的记录上设置共享记录级锁定以检查约束.InnoDB还在约束失败的情况下设置这些锁.</p>
</li>
<li><p>LOCK TABLES设置表锁,但它是设置这些锁的InnoDB层之上的更高的MySQL层.如果innodb_table_locks &#x3D; 1(默认值)和autocommit &#x3D; 0，InnoDB知道表锁，并且InnoDB上方的MySQL层知道行级锁.</p>
<p>  否则,InnoDB的自动死锁检测无法检测到涉及此类表锁的死锁.此外,因为在这种情况下,较高的MySQL层不知道行级锁,所以可以在另一个会话当前具有行级锁的表上获得表锁.但是，这不会危及事务的完整性.</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://misakatang.cn/2019/03/30/InnoDB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-14-7-InnoDB%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B-14-7-1-InnoDB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/misaka.jpg">
      <meta itemprop="name" content="MisakaTang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MisakaTang's Blog">
      <meta itemprop="description" content="The limits of my language are the limits of my world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | MisakaTang's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/30/InnoDB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-14-7-InnoDB%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B-14-7-1-InnoDB%E9%94%81/" class="post-title-link" itemprop="url">InnoDB官方文档--14.7 InnoDB锁和事务模型|14.7.1 InnoDB锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-30 15:33:05" itemprop="dateCreated datePublished" datetime="2019-03-30T15:33:05+00:00">2019-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-14 08:33:24" itemprop="dateModified" datetime="2024-03-14T08:33:24+00:00">2024-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="14-7-InnoDB锁和事务模型"><a href="#14-7-InnoDB锁和事务模型" class="headerlink" title="14.7 InnoDB锁和事务模型"></a>14.7 InnoDB锁和事务模型</h3><p>为了实现大规模,繁忙或高可靠的数据库应用,从不同的数据库系统移植大量代码或调整MySQL性能,理解InnoDB锁和InnoDB事务模型是很重要的.</p>
<p>这个部分讨论了几个你应该要熟悉的和InnoDB锁和InnoDB事务模型相关的主题.</p>
<ul>
<li>14.7.1 InnoDB锁 描述了InnoDB中使用的锁类型.</li>
<li>14.7.2 InnoDB事务模型 描述了事务隔离级别和每个锁的使用策略.同时也讨论了autocommit的使用,一致的无锁读和锁定读取.</li>
<li>14.7.3 InnoDB中不同SQL语句设置的锁 讨论了InnoDB中为各种语句设置的特定锁类型.</li>
<li>14.7.4 幻想行 描述InnoDB如何使用下一个键锁定来避免幻像行</li>
<li>14.7.5 InnoDB中的死锁 提供了一个死锁示例,讨论了死锁检测和回滚,并提供了在InnoDB中最小化和处理死锁的技巧.</li>
</ul>
<h4 id="14-7-1-InnoDB锁"><a href="#14-7-1-InnoDB锁" class="headerlink" title="14.7.1 InnoDB锁"></a>14.7.1 InnoDB锁</h4><p><strong>共享和独占锁(Shared and Exclusive Locks)</strong></p>
<p>InnoDB实现了标准的行级锁,包括两种类型:共享锁和独占锁.</p>
<ul>
<li>共享锁(S锁)允许持有锁的事务读取行.</li>
<li>独占锁(X锁)允许持有锁的事务更新或删除行.</li>
</ul>
<p>如果事务T1持有行r的共享锁,之后来自不同事务T2对行r的锁的请求处理如下:</p>
<ul>
<li>可以立即授予T2一个共享锁.结果是T1和T2都持有对行r的共享锁.</li>
<li>对T2事务的独占锁请求不能马上授予.</li>
</ul>
<p>如果事务T1持有行r的独占锁,来自不同事务T2的获取锁的请求不能立即授予.相反,T2要等到T1释放对行r的锁(才能获得锁).</p>
<p><strong>意图锁(Intention Locks)</strong></p>
<p>InnoDB支持多粒度锁定允许行级锁和表级锁共存.例如,语句<code>LOCK TABLES ... WRITE</code>在指定表上获取一个独占锁.为了在多个粒度上实现加锁,InnoDB使用意图锁.意图锁是一个表级锁,用来指明下一个事务对表中的行所需要的所类型(共享或独占).有两种类型的意图锁:</p>
<ul>
<li>意图共享锁(IS锁)表示事务打算在表的行上设置共享锁.</li>
<li>意图独占锁(IX锁)表示事务打算在表的行上设置独占锁.</li>
</ul>
<p>例如,<code>SELECT ... LOCK IN SHARE MODE</code>设置一个IS锁,<code>SELECT ... FOR UPDATE</code>设置一个IX锁.</p>
<p>意图锁的规则如下:</p>
<ul>
<li>如果一个事务可以在表的行上获取共享锁,它一定要先在表上获取一个IS锁或更强的锁.</li>
<li>如果一个事务可以在表的行上获取独占锁,它一定要先在表上获取一个IX锁.</li>
</ul>
<p>表级锁类型兼容总结如下:</p>
<p><img src="https://i.loli.net/2019/03/26/5c99d3d734beb.png"> </p>
<p>如果请求事务与现有锁兼容,则授予锁,但如果它与现有锁冲突则不授予.事务会等待直到冲突的锁被释放.如果加锁请求和现有的锁冲突会无法授予,因为这会导致死锁而发生错误.</p>
<p>意图锁不会阻止任何请求除了对全表加锁的请求(例如<code>LOCK TABLES ... WRITE</code>).意图锁的主要用途是展示某人正在对行加锁或将要对表中的行加锁.</p>
<p>意图锁的事务数据在<code>SHOW ENGINE INNODB STATUS</code>和InnoDB监视器输出显示类似下面的内容:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TABLE LOCK table `test`.`t` trx id 10080 lock mode IX</span><br></pre></td></tr></table></figure>

<p><strong>记录锁(Record Locks)</strong></p>
<p>记录锁是在索引记录上的锁.例如,<code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code>会阻止其他任何事务对t.c1&#x3D;10的行的插入,更新或删除操作.</p>
<p>记录锁总是对索引记录加锁,甚至表定义中没有索引.在这种情况下,InnoDB创建一个隐藏的聚簇索引并用来作为记录锁的索引.</p>
<p>记录锁的事务数据在<code>SHOW ENGINE INNODB STATUS</code>和InnoDB监视器输出显示类似下面的内容:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t` </span><br><span class="line">trx id 10078 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &#x27;O;;</span><br><span class="line"> 2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure>

<p><strong>间隙锁(Gap Locks)</strong></p>
<p>间隙锁是一个锁定两个索引记录之间间隙的锁,或是锁定第一个之前或最后一个索引记录之后的间隙.例如,<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>会阻止其他事务插入15到列t.c1中,无论这一列中是否已经有这个值了,因为所有存在的值之间的间隙已经被锁定了.</p>
<p>间隙可能跨越一个索引值,多个索引值甚至为空.</p>
<p>间隙锁是性能和并发之间权衡的一部分,用于一些事务隔离级别中.</p>
<p>使用唯一索引锁定行搜索唯一行的语句不需要间隙锁.(这不包括搜索条件仅包括多列唯一索引的一些列的情况;在这种情况下,会发生间隙锁定).例如,如果ID列有一个唯一索引,下面的语句只对id值为100的行加索引记录锁而其他会话是否在前面的间隙中插入行都没关系:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> child <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>如果id列没有被索引或有一个非唯一索引,上面的语句会在前面的间隙加锁.</p>
<p>值得注意的是,冲突锁可以通过不同的事务保持在间隙上.例如,当事务A在a间隙上持有一个共享间隙锁(gap S-lock)上时B事务可以在相同的间隙上持有独占间隙锁(gap X-lock).允许间隙锁冲突的原因是如果索引上的记录被清除,则必须合并由不同事务保留在记录上的间隙锁.</p>
<p>InnoDB中的间隙锁是”单纯抑制(purely inhibitive)”,也就是说其目的就是阻止其他事务插入数据到间隙.间隙锁可以共存.一个事务获取了间隙锁不会阻止其他事务在同一个间隙上获取间隙锁.在共享和独占的间隙锁上没有区别.它们彼此不冲突并且执行相同的功能.</p>
<p>可以明确禁用间隙锁.如果你改变事务隔离级别到 READ COMMITTED或启用<code> innodb_locks_unsafe_for_binlog</code>系统变量(现已弃用)就会发生.在这种情况下,间隙锁对搜索和索引扫描禁用并且只用在外键约束检查和重复键检查.</p>
<p>使用 READ COMMITTED事务隔离级别或启用<code> innodb_locks_unsafe_for_binlog</code>还有其他影响.MySQL求值WHERE条件之后会释放不匹配行的记录锁.对UPDATE语句,InnoDB会执行”半一致(semi-consistent)”读,这样就会将最新提交的版本返回给MySQL,以便MySQL确定该行是否与UPDATE的WHERE条件匹配.</p>
<p><strong>Next-Key锁</strong></p>
<p>next-key锁是索引记录上的记录锁和索引记录之前的间隙上的间隙锁的组合.</p>
<p>InnoDB以这样的方式执行行级锁定:当搜索或扫描表索引时,会在遇到的索引记录上设置共享锁或排它锁.因此,行级锁实际上是索引记录锁.索引记录上的next-key锁也会影响索引记录前的”间隙”.也就是说,next-key锁是一个索引记录锁加上一个索引记录之前的间隙上的间隙锁.如果一个会话在索引的记录R上有一个共享或者独占锁,另一个会话不能在R的索引顺序前面的间隙里立即插入一个新的索引记录.</p>
<p>假设一个索引包含10,11,13和20.这个索引可能的next-key锁包含下面的范围,圆括号表示不包含边界,方括号表示包含边界:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure>
<p>对最后一个间隔,next-key锁在索引的最大值之上加锁并且这个”最大数”的伪记录比索引中实际存在的任何值都大.最大数不是一个真的索引记录,所以实际上,这个next-key锁只是对最大索引值之后加锁.</p>
<p>默认情况下,InnoDB在 REPEATABLE READ的事务隔离级别下操作.在这种情况下,InnoDB用next-key锁来搜索和扫描索引,这样可以防止幻影行(phantom rows).</p>
<p>next-key锁的事务数据在<code>SHOW ENGINE INNODB STATUS</code>和InnoDB监视器输出显示类似下面的内容:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t` </span><br><span class="line">trx id 10080 lock_mode X</span><br><span class="line">Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &#x27;O;;</span><br><span class="line"> 2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure>

<p><strong>插入意图锁(Insert Intention Locks)</strong></p>
<p>插入意图锁是在行插入前由INSERT操作设置的一种间隙锁.该锁以这样的方式来表示插入的意图:插入相同索引间隙的多个事务不需要互相等待如果它们没有插入到间隙内的相同位置的话.假设有4和7两个索引记录值.两个事务分别要插入值5和6,在获得插入行上的独占锁之前,每个事务都使用插入意图锁锁定4到7之间的间隙,但是不要因为行是不冲突的就不互相阻塞.</p>
<p>下面的例子展示了一个事务在获得插入记录的独占锁之前获取一个插入意图锁.这个例子涉及2个客户端,A和B.</p>
<p>客户端A创建了一个包含2个索引记录(90和102)的表并且开始了一个事务对ID大于100的索引加了独占锁.这个独占锁包含了记录102之前的间隙:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> child (id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY(id)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> child (id) <span class="keyword">values</span> (<span class="number">90</span>),(<span class="number">102</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> child <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span> id  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">102</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br></pre></td></tr></table></figure>
<p>客户端B开始一个事务并向间隙中插入记录.当其等待获取独占锁的时候获得了一个插入意图锁.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> child (id) <span class="keyword">VALUES</span> (<span class="number">101</span>);</span><br></pre></td></tr></table></figure>
<p>插入意图锁的事务数据在<code>SHOW ENGINE INNODB STATUS</code>和InnoDB监视器输出显示类似下面的内容:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`</span><br><span class="line">trx id 8731 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000066; asc    f;;</span><br><span class="line"> 1: len 6; hex 000000002215; asc     &quot; ;;</span><br><span class="line"> 2: len 7; hex 9000000172011c; asc     r  ;;...</span><br></pre></td></tr></table></figure>

<p><strong>自增锁(AUTO-INC Locks)</strong></p>
<p>自增锁是由插入到具有自增(AUTO_INCREMENT)列的表中的事务所采用特殊的表级锁.在最简单的情况下,如果一个事务正在往一个表里插入数据,其他事务必须等待对该表执行插入以便第一个事务插入的行能得到连续的主键值.</p>
<p><code>innodb_autoinc_lock_mode</code>配置选择控制了自增锁使用的算法.允许你在可预测的自动增量值序列和插入操作的最大并发之间进行权衡.</p>
<p><strong>空间索引谓词锁(Predicate Locks for Spatial Indexes)</strong></p>
<p>InnoDB支持包含空间列的空间(SPATIAL)索引.</p>
<p>为了处理涉及空间索引的操作的锁定,next-key锁在<code>REPEATABLE READ</code>或<code> SERIALIZABLE</code>事务隔离级别上运行不是很好.多维数据中没有绝对排序概念,因此不清楚哪个是”下一个(next-key)”主键.</p>
<p>为了支持具有空间(SPATIAL)索引的表的隔离级别,InnoDB使用谓词锁.空间索引包含最小边界矩形(MBR)值,因此InnoDB通过在用于查询的MBR值上设置谓词锁来强制对索引进行一致读取.其他事务无法插入或修改与查询条件匹配的行.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://misakatang.cn/2019/03/30/InnoDB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-14-6-6-Redo%E6%97%A5%E5%BF%97-14-6-7-undo%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/misaka.jpg">
      <meta itemprop="name" content="MisakaTang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MisakaTang's Blog">
      <meta itemprop="description" content="The limits of my language are the limits of my world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | MisakaTang's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/30/InnoDB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-14-6-6-Redo%E6%97%A5%E5%BF%97-14-6-7-undo%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">InnoDB官方文档--14.6.6 Redo日志|14.6.7 undo日志</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-30 15:24:30" itemprop="dateCreated datePublished" datetime="2019-03-30T15:24:30+00:00">2019-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-14 08:33:24" itemprop="dateModified" datetime="2024-03-14T08:33:24+00:00">2024-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="14-6-6-Redo日志"><a href="#14-6-6-Redo日志" class="headerlink" title="14.6.6 Redo日志"></a>14.6.6 Redo日志</h4><p>redo 日志是一个基于磁盘的数据结构,在崩溃恢复期间用于纠正由不完整事务写入的数据.在正常操作期间,redo日志对更改由SQL语句或低级API调用产生的表数据的请求进行编码.未完成更新数据文件的修改会在以外关闭自动重启的初始化期间和连接接受之前完成.</p>
<p>默认情况下,redo日志在磁盘上由两个名为ib_logfile0和ib_logfile1的文件表示.MySQL以循环方式写入redo日志文件.redo日志中的数据根据​​受影响的记录进行编码;这些数据统称为redo.通过redo日志的数据传递由不断增加的LSN值表示.</p>
<p><strong>改变InnoDB redo日志文件的数量或大小</strong></p>
<p>为了改变InnoDB redo日志文件的大小或数量,执行下面的步骤:</p>
<ol>
<li>停止MySQL服务并且保证关闭时没有错误.</li>
<li>编辑my.cnf改变日志文件配置.修改<code> innodb_log_file_size</code>来改变日志文件的大小,修改<code>innodb_log_files_in_group</code>来增加日志文件的数量.</li>
<li>再次启动MySQL服务.</li>
</ol>
<p>InnoDB如果检测到redo日志文件大小和<code> innodb_log_file_size</code>不一样,会写下日志检查点,关闭和删除旧的日志文件,按照需要的大小创建新的日志文件并且打开新的日志文件(使用).</p>
<p><strong>redo日志刷新的分组提交(Group Commit for Redo Log Flushing)</strong></p>
<p>InnoDB和其他任何符合ACID标准的数据库引擎一样,在提交事务之前刷新事务的redo日志.InnoDB使用组提交功能将多个刷新请求组合在一起来避免每次只提交一个刷新.通过组提交,InnoDB会对日志文件发出一次写入操作来为同时提交的多个用户事务执行提交操作,从而显着提高吞吐量.</p>
<h4 id="14-6-7-undo日志"><a href="#14-6-7-undo日志" class="headerlink" title="14.6.7 undo日志"></a>14.6.7 undo日志</h4><p>undo日志是与单个读写事务关联的undo日志记录的集合.undo日志包含了如何撤销最近由事务引起的聚簇索引记录变化的信息.如果另一个事务需要将原始数据视为一致读取操作的一部分,没有修改的数据可以从undo日志记录中恢复.undo日志存在于undo日志段中,包含在回滚段之内.回滚段位于系统表空间,undo表空间和临时表空间中.</p>
<p>临时表空间中的undo日志用来修改用户定义的临时表中的数据的事务.这些undo日志不会被redo日志记录,因为它们不是崩溃恢复必要的日志.它们只用来在服务器运行时的回滚.这种类型的undo日志的好处是避免了redo日志执行需要的I&#x2F;O.</p>
<p>InnoDB支持最大128个回滚段,其中的32个用于临时表空间.剩余的96个回滚段用于正常表的事务数据修改.<code> innodb_rollback_segments</code>变量定义InnoDB使用的回滚段的数量.</p>
<p>回滚段中的撤消槽数根据InnoDB页面大小而不同.</p>
<p><img src="https://i.loli.net/2019/03/25/5c98946a0bb1b.png"> </p>
<p>事务最多分配4个undo日志，每个日志对应于以下每种操作类型:</p>
<ol>
<li>用户定义表(user-defined tables)上的INSERT操作.</li>
<li>用户定义表(user-defined tables)上的UPDATE和DELETE操作.</li>
<li>用户定义临时表上的INSERT操作.</li>
<li>用户定义临时表上的UPDATE和DELETE操作.</li>
</ol>
<p>根据需要分配undo日志.例如,对常规表和临时表执行INSERT,UPDATE和DELETE操作的事务需要完全分配四个撤消日志.只对常规表执行INSERT操作的事务需要一个undo日志.</p>
<p>在常规表上执行的事务操作从分配的系统表空间或undo表空间回滚段中分配undo日志.在临时表上执行的事务操作从分配的临时表空间中分配undo日志.</p>
<p>分配给事务的undo日志在事务持续时间事务相关联.例如,分配给常规表上INSERT操作的事务的undo日志用于该事务执行的常规表上的所有INSERT操作.</p>
<p>鉴于上述因素,可以使用以下公式来估计InnoDB能够支持的并发读写事务的数量.</p>
<ul>
<li>如果每个事务都执行INSERT或UPDATE或DELETE操作,InnoDB能够支持的并发读写事务的数量是:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(innodb_page_size / 16) * (innodb_rollback_segments - 32)</span><br></pre></td></tr></table></figure></li>
<li>如果每个事务分别执行INSERT和UPDATE或DELETE操作,则InnoDB能够支持的并发读写事务的数量是:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(innodb_page_size / 16 / 2) * (innodb_rollback_segments - 32)</span><br></pre></td></tr></table></figure></li>
<li>如果每个事务对临时表执行INSERT操作,则InnoDB能够支持的并发读写事务的数量是:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果每个事务对临时表执行INSERT操作，则InnoDB能够支持的并发读写事务的数量是</span><br></pre></td></tr></table></figure></li>
<li>如果每个事务对临时表执行INSERT和UPDATE或DELETE操作,则InnoDB能够支持的并发读写事务的数量是:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(innodb_page_size / 16 / 2) * 32</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/15/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">MisakaTang</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/TangMisaka23001" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","mhchem":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
