<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"misakatang.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"style":null,"show_result":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="The limits of my language are the limits of my world">
<meta property="og:type" content="website">
<meta property="og:title" content="MisakaTang&#39;s Blog">
<meta property="og:url" content="http://misakatang.cn/page/21/index.html">
<meta property="og:site_name" content="MisakaTang&#39;s Blog">
<meta property="og:description" content="The limits of my language are the limits of my world">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="MisakaTang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://misakatang.cn/page/21/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/21/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MisakaTang's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4TSLH4NC9H"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-4TSLH4NC9H","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?de7c77febeeac252eee468207ae11ce4"></script>



  <script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "jtb4czrfeu");
</script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="MisakaTang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">MisakaTang's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MisakaTang"
      src="/images/misaka.jpg">
  <p class="site-author-name" itemprop="name">MisakaTang</p>
  <div class="site-description" itemprop="description">The limits of my language are the limits of my world</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/%E5%BD%92%E6%A1%A3/">
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/TangMisaka23001" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TangMisaka23001" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mikasatang@gmail.com" title="E-Mail → mailto:mikasatang@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="http://blog.bbchen.top/" title="http:&#x2F;&#x2F;blog.bbchen.top" rel="noopener" target="_blank">BB chen的漂流记</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://blog.zhuzhenyuan.cn/" title="http:&#x2F;&#x2F;blog.zhuzhenyuan.cn" rel="noopener" target="_blank">Aurthur_的博客</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://misakatang.cn/2018/10/18/%E7%BF%BB%E8%AF%91-Spring-MVC-Test-Framework-MockMvc%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/misaka.jpg">
      <meta itemprop="name" content="MisakaTang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MisakaTang's Blog">
      <meta itemprop="description" content="The limits of my language are the limits of my world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | MisakaTang's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/18/%E7%BF%BB%E8%AF%91-Spring-MVC-Test-Framework-MockMvc%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">翻译:Spring MVC Test Framework--MockMvc使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-18 20:44:18" itemprop="dateCreated datePublished" datetime="2018-10-18T20:44:18+00:00">2018-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-14 08:33:24" itemprop="dateModified" datetime="2024-03-14T08:33:24+00:00">2024-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>国庆回来之后算是正是开始了Spring Boot的工作,而Java组里因为没有写任何的单元测试,每次测试都是靠Swagger的web页面自己填参数来测试,于是在这次新版本的迭代中我变成了第一个被要求贯彻实施每个controller都要写测试的人,不过<strong>单元测试,从我做起</strong>,真的很重要啊.</p>
<p>然后在选择的时候发现了MockMvc这个Spring自带的测试利器,个人认为主要的优势就在于可以直接在Java中模拟HTTP请求,而且对于模拟请求和参数的解析也是一把好手,<em>当然就是选择它啊!</em>,我当然是赞成的.然后在寻找资料的时候因为一开始没有看官方文档也是被搞懵了很久,在看了官方文档之后才豁然开朗,于是就为了自己,翻译一下记录一下,以防健忘的自己以后重复找轮子.</p>
<p>这里是文档地址:<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testing-introduction">https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testing-introduction</a>,因为这次只测试和服务器端的单元测试,所以文档也就翻了这部分.</p>
<h1 id="Spring-MVC-Test-Framework"><a href="#Spring-MVC-Test-Framework" class="headerlink" title="Spring MVC Test Framework"></a>Spring MVC Test Framework</h1><p>Spring MVC Test框架为使用流畅的API测试Spring MVC代码提供了最高级的支持,你可以使用JUnit,TestNG或者其他任何的测试框架.它被构建在<code>spring-test</code>模块的<a href="#jump">Servlet API mock 对象</a>之上,因此不使用运行中的Servlet容器.它使用<code>DispatcherServlet</code>来提供完整的Spring MVC运行时的行为并且除了独立的模块之外还提供了使用TestContext框架来加载实际的Spring配置的支持,也就是说你可以手动执行Controller的实例并且一次测试一个.</p>
<p>Spring MVC Test还使用<code>RestTemplate</code>来提供客户端的代码测试.客户端的测试模拟服务端的响应所以也不会使用正在运行的服务.</p>
<blockquote>
<p>Spring Boot提供了一个选项来写一个完整的,端到端的包含运行中服务的集成测试.如果这是你的目标,查看<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications">Spring Boot reference page</a>.获取更多关于容器外和端到端集成测试的区别的信息,查看<a href="#jump">Differences Between Out-of-Container and End-to-End Integration Tests</a></p>
</blockquote>
<h2 id="Server-Side-Tests"><a href="#Server-Side-Tests" class="headerlink" title="Server-Side Tests"></a>Server-Side Tests</h2><p>你可以使用JUnit或者TestNG为Spring MVC controller编写一个普通的单元测试.如果要这么做的话,实例化conreoller,使用mocked或者stubbed依赖注入,然后使用它们的方法就行了(例如:<code>MockHttpServletRequest</code>,<code>MockHttpServletResponse</code>,和其他有必要用到的).然而,当你这样来写单元测试的时候,很多东西是测试不到的,例如:RequestMapping,数据绑定,类型转换,数据的合法性验证等等.此外,其他的controller方法,例如<code>@InitBinder</code>,<code>@ModelAttribute</code>和<code>@ExceptionHandler</code>也会作为请求过程生命周期中的一部分被请求到.</p>
<p>Spring MVC Test的目标是提供一个高效的方式来测试controller通过执行请求和生成response通过实际的<code>DispatcherServlet</code>.</p>
<p>Spring MVC Test构建在熟悉的<code>spring-test</code>模块的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#mock-objects-servlet">“mock” implementations of the Servlet API</a>之上.这也就允许我们不需要运行一个Servlet容器就可以模拟请求和生成response.在大部分情况下,一切都会像真实环境一样工作但是也有几个例外:[Differences Between Out-of-Container and End-to-End Integration Tests](### Differences Between Out-of-Container and End-to-End Integration Tests).下面的代码是基于JUnit Jupiter使用Spring MVC Test的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringJUnitWebConfig(locations = &quot;test-servlet-context.xml&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">(WebApplicationContext wac)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getAccount</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.mockMvc.perform(get(<span class="string">&quot;/accounts/1&quot;</span>)</span><br><span class="line">        .accept(MediaType.parseMediaType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>)))</span><br><span class="line">        .andExpect(status().isOk())</span><br><span class="line">        .andExpect(content().contentType(<span class="string">&quot;application/json&quot;</span>))</span><br><span class="line">        .andExpect(jsonPath(<span class="string">&quot;$.name&quot;</span>).value(<span class="string">&quot;Lee&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的测试依赖于TestContext框架提供支持的<code>WebApplicationContext</code>来从位于相同的package的xml配置文件中加载Spring的配置,基于Java和Groovy的配置文件也是支持的.<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples/context">看这里</a></p>
<p>MockMVC实例模拟了一个<code>GET</code>请求了<code>/accounts/1</code>并且验证response的结果状态码是200,content-type是<code>application/json</code>,并且response body有一个JSON属性名<code>name</code>的key值是<code>Lee</code>.<code>jsonPath</code>的语法通过Jayway<a target="_blank" rel="noopener" href="https://github.com/jayway/JsonPath">JsonPath project</a>提供支持.更多其他的关于验证结果和模拟请求的选项在后面的文档中会讨论.</p>
<h3 id="Static-Imports"><a href="#Static-Imports" class="headerlink" title="Static Imports"></a>Static Imports</h3><p>上面例子代码中的API需要几个静态的imports,例如<code>MockMvcRequestBuilders.*</code>,<code>MockMvcResultMatchers.*</code>和<code>MockMvcBuilders.*</code>.下面导包操作就省略了.</p>
<h3 id="Setup-Choices"><a href="#Setup-Choices" class="headerlink" title="Setup Choices"></a>Setup Choices</h3><p>你有2种主要的方式来创建<code>MockMVC</code>实例.第一种是通过TestContext框架加载Spring MVC配置文件,这样会加载Spring的配置信息并且通过注入<code>WebApplicationContext</code>到测试中来构建一个<code>MockMVC</code>实例.下面是示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;my-servlet-context.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(<span class="built_in">this</span>.wac).build();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种选择是手动创建一个controller实例而不加载Spring的配置信息.相对的,通过大致比较MVC JavaConfig或者MVC namespace来自动的创建一个默认的配置.你可以在一定程度上自定义.下面是实例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mockMvc = MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> <span class="title class_">AccountController</span>()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会选择哪一种方式呢?#反正我是第二种hhh</p>
<p><code>webAppContextSetup</code>会加载你实际的Spring MVC配置信息,导致一个更完整的集成测试.自从TestContext框架缓存加载Spring配置信息之后会让测试运行的更快,甚至在你引入了更多的测试的时候.此外,你可以通过Spring configuration注入mock service到你的controller以便于专注地在web层进行测试.下面的例子声明了一个mock service使用Mockito:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mockito.Mockito&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;mock&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;org.example.AccountService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后你可以把mock service注入到测试中并且配置成你想要的样子.下面是示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;test-servlet-context.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种<code>单独的设置</code>,从另一个方面看更接近一个单元测试,每次只测试一个controller.你可以使用mock依赖手动注入controller,并且这不涉及到加载Spring配置信息.这种测试更加关注于”style”并且让看到哪个controller正在被测试变得更容易,是否需要特定的Spring MVC配置文件才能运行,等等.这种<code>单独设置</code>的方式也是一种便利的写ad-hoc测试来验证具体的行为或者debug一个issue的方式.</p>
<p>在集成和单元测试的争论下,没有对的或者错的答案.然而使用<code>单独设置</code>就意味着需要额外的<code>webAppContextSetup</code>测试来验证你的Sring配置文件.或者你也可以用<code>webAppContextSetup</code>来写你的所有的测试,这样可以始终测试你的Spring配置信息.</p>
<h3 id="Setup-Features"><a href="#Setup-Features" class="headerlink" title="Setup Features"></a>Setup Features</h3><p>无论你使用那种方式来构建MockMVC,所有的<code>MockMvcBuilder</code>实现都提供了一些常见并且很实用的特性.例如,你可以为所有的请求声明一个<code>Accept</code>头并且对于所有的response希望返回200的状态码和<code>Content-Type</code>头.下面是示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static import of MockMvcBuilders.standaloneSetup</span></span><br><span class="line"></span><br><span class="line"><span class="type">MockMvc</span> <span class="variable">mockMvc</span> <span class="operator">=</span> standaloneSetup(<span class="keyword">new</span> <span class="title class_">MusicController</span>())</span><br><span class="line">    .defaultRequest(get(<span class="string">&quot;/&quot;</span>).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">    .alwaysExpect(status().isOk())</span><br><span class="line">    .alwaysExpect(content().contentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>此外,第三方框架(和应用)可以预先打包设置声明,比如在<code>MockMvcConfigurer</code>.Spring框架有一个内置的实现可以通过请求来保存和重用HTTP session.你可以像下面一样使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static import of SharedHttpSessionConfigurer.sharedHttpSession</span></span><br><span class="line"></span><br><span class="line"><span class="type">MockMvc</span> <span class="variable">mockMvc</span> <span class="operator">=</span> MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> <span class="title class_">TestController</span>())</span><br><span class="line">    .apply(sharedHttpSession())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use mockMvc to perform requests...</span></span><br></pre></td></tr></table></figure>
<p>查看<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.1.RELEASE/javadoc-api/org/springframework/test/web/servlet/setup/ConfigurableMockMvcBuilder.html">Javadoc for <code>ConfigurableMockMvcBuilder</code></a>,列出了所有MockMvc内建的特性或者使用ide来查看.</p>
<h3 id="Performing-Requests"><a href="#Performing-Requests" class="headerlink" title="Performing Requests"></a>Performing Requests</h3><p>你可以使用任何的HTTP方法来模拟请求:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(post(<span class="string">&quot;/hotels/&#123;id&#125;&quot;</span>, <span class="number">42</span>).accept(MediaType.APPLICATION_JSON));</span><br></pre></td></tr></table></figure>
<p>你也可以使用<code>MockMultipartHttpServletRequest</code>内的模拟文件上传请求,这样就不会实际的解析一个多部分的请求.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(multipart(<span class="string">&quot;/doc&quot;</span>).file(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;ABC&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>你可以添加一个请求参数使用URI template风格:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">&quot;/hotels?thing=&#123;thing&#125;&quot;</span>, <span class="string">&quot;somewhere&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>你还可以添加Servlet请求参数不管是请求参数还是表单参数.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">&quot;/hotels&quot;</span>).param(<span class="string">&quot;thing&quot;</span>, <span class="string">&quot;somewhere&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>如果应用的编码依赖于Servlet请求参数并且没有明确检查请求的字符串,你使用那个选项都没关系.但是请记住,提供的请求参数使用URI template的时候被编码,在请求参数经过<code>param()</code>方法的时候是预计已经被编码的.</p>
<p>在大多数的情况下,最好是把context path和Servlet path放在请求的URI外面.如果你必须要在完整的URI下测试,确定设置了<code>contextPath</code>和<code>servletPath</code>,request mapping才能正常工作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">&quot;/app/main/hotels/&#123;id&#125;&quot;</span>).contextPath(<span class="string">&quot;/app&quot;</span>).servletPath(<span class="string">&quot;/main&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>在上面的例子里,给每个模拟请求设置<code>contextPath</code>和<code>servletPath</code>是很笨重的.你可以设置默认的请求参数来代替:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebTests</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Before</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line"> mockMvc = standaloneSetup(<span class="keyword">new</span> <span class="title class_">AccountController</span>())</span><br><span class="line">    .defaultRequest(get(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    .contextPath(<span class="string">&quot;/app&quot;</span>).servletPath(<span class="string">&quot;/main&quot;</span>)</span><br><span class="line">    .accept(MediaType.APPLICATION_JSON)).build();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面的设置会影响所有通过这个MockMvc实例模拟的请求.如果相同的属性也在给定的请求里出现了,会覆盖默认的值.这也就是为什么HTTP方法和URI在默认的请求下没有影响,因为必须在每个请求中指定它们.</p>
<h3 id="Defining-Expectations"><a href="#Defining-Expectations" class="headerlink" title="Defining Expectations"></a>Defining Expectations</h3><p>你可以定义预计的结果通过添加一个或者更多的<code>.andExpect(..)</code>在模拟请求之后:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">&quot;/accounts/1&quot;</span>)).andExpect(status().isOk());</span><br></pre></td></tr></table></figure>
<p><code>MockMvcResultMatchers.*</code>提供了大量的expectations,其中一些嵌套了更详细的expectations.</p>
<p>Expectations分为两大类,第一类断言验证响应的属性,这些都是最重要的结果断言.</p>
<p>第二类断言超出了response的范围,这些断言可以让你检查Spring MVC的特定方面,例如哪个controller的方法处理了请求,是否一个异常被抛出和处理,模型的content是什么,哪个view被选择,哪些属性被添加,等等..他们也运行检查Servlet的特定方面,例如请求和会话属性.</p>
<p>下面的测试断言绑定或者验证失败:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(post(<span class="string">&quot;/persons&quot;</span>))</span><br><span class="line">    .andExpect(status().isOk())</span><br><span class="line">    .andExpect(model().attributeHasErrors(<span class="string">&quot;person&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>很多时候,当你在写测试,打印出模拟请求的结果是很有帮助的,可以使用<code>MockMvcResultHandlers</code>的静态方法<code>print()</code>来做到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(post(<span class="string">&quot;/persons&quot;</span>))</span><br><span class="line">    .andDo(print())</span><br><span class="line">    .andExpect(status().isOk())</span><br><span class="line">    .andExpect(model().attributeHasErrors(<span class="string">&quot;person&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>只要请求过程没有造成一个没有处理的异常,<code>print()</code>方法就会打印出所有可得到的结果数据到<code>System.out</code>.Spring Framework 4.2引入了一个<code>log()</code>方法和两个附加的变种的<code>print()</code>方法,一个接收<code>OutputStream</code>一个接收<code>Writer</code>.例如,请求<code>print(System.err)</code>打印结果到<code>System.err</code>.当请求<code>print(myWriter)</code>的时候会打印数据到规定的地方.如果你想要使用结果数据日志来代替打印,使用<code>log()</code>方法,会把数据使用<code>DEBUG</code>打到<code>org.springframework.test.web.servlet.result</code>配置下.</p>
<p>在某些情况下,你也许想直接访问并且不想验证其他结果可以在后面加<code>.andReturn()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MvcResult</span> <span class="variable">mvcResult</span> <span class="operator">=</span> mockMvc.perform(post(<span class="string">&quot;/persons&quot;</span>)).andExpect(status().isOk()).andReturn();</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>如果所有的测试有使用相同的expectations,你可以设置一个公共的expectations构建在<code>MockMvc</code>实例里面:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">standaloneSetup(<span class="keyword">new</span> <span class="title class_">SimpleController</span>())</span><br><span class="line">    .alwaysExpect(status().isOk())</span><br><span class="line">    .alwaysExpect(content().contentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>))</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>
<p>注意公用的expectations总是会被使用并且无法被覆盖.</p>
<p>当JSON响应内容包含使用<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>创建的超媒体链接时.你可以使用JsonPath表达式来验证结果连接:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">&quot;/people&quot;</span>).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">    .andExpect(jsonPath(<span class="string">&quot;$.links[?(@.rel == &#x27;self&#x27;)].href&quot;</span>).value(<span class="string">&quot;http://localhost:8080/people&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>当xml被包含的时候可以使用xpath表达式来验证:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; ns = Collections.singletonMap(<span class="string">&quot;ns&quot;</span>, <span class="string">&quot;http://www.w3.org/2005/Atom&quot;</span>);</span><br><span class="line">mockMvc.perform(get(<span class="string">&quot;/handle&quot;</span>).accept(MediaType.APPLICATION_XML))</span><br><span class="line">    .andExpect(xpath(<span class="string">&quot;/person/ns:link[@rel=&#x27;self&#x27;]/@href&quot;</span>, ns).string(<span class="string">&quot;http://localhost:8080/people&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="Filter-Registrations"><a href="#Filter-Registrations" class="headerlink" title="Filter Registrations"></a>Filter Registrations</h3><p>当设置一个<code>MockMvc</code>实例的时候,你可以注册一个或多个Servlet <code>Filter</code>实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc = standaloneSetup(<span class="keyword">new</span> <span class="title class_">PersonController</span>()).addFilters(<span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>()).build();</span><br></pre></td></tr></table></figure>
<p>注册过滤通过<code>spring-test</code>的<code>MockFilterChain</code>来调用,并且把最后一个过滤器委托给<code>DispatcherServlet</code>.</p>
<p><span id="jump"></span></p>
<h3 id="Differences-Between-Out-of-Container-and-End-to-End-Integration-Tests"><a href="#Differences-Between-Out-of-Container-and-End-to-End-Integration-Tests" class="headerlink" title="Differences Between Out-of-Container and End-to-End Integration Tests"></a>Differences Between Out-of-Container and End-to-End Integration Tests</h3><p>就像之前提到的,Spring MVC Test构建在<code>spring-test</code>的Servlet API mock objects之上并且没有使用运行中的Servlet容器.因此,这和在客户端和服务器运行的完整的端到端的集成测试有一些很重要的区别.</p>
<p>最简单的方式就是从思考一个空白的<code>MockHttpServletRequest</code>开始.在这里面你添加什么,请求就会变成什么样.令你吃惊的也许是这里没有完整的上下文路径在默认情况下,没有<code>jsessionid</code>的cookie,没有转发,错误或是异步调度并且因此,没有实际的JSP转义.与此相对的,转发和重定向URL被保存在<code>MockHttpServletResponse</code>里并且可以使用表达式来断言它.</p>
<p>这也就意味着,如果你使用JSP,你可以验证请求转发到的JSP页面,但是没有HTML被呈现.换句话说,JSP不会被调用.但请注意，所有其他不依赖转发的渲染技术,例如Thymeleaf和Freemarker,会在response body里像期待的那样呈现HTML内容.相同的,JSON,XML和其他一切通过<code>@ResponseBody</code>注解传递的格式都可以.</p>
<p>另外,你也可以考虑通过使用Spring Boot的<code>@WebIntegrationTest</code>来实现完整的端到端的集成测试.查看<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications">Spring Boot Reference Guide</a>.</p>
<p>每种方法都有利弊.Spring MVC Test提供的选项和传统的单元测试的完整集成测试所停留的面是不一样的.可以肯定的是,Spring MVC中没有任何属于传统单元测试的选项,但是有一点接近它.例如,你可以通过把mock service注入到controller中的方式来隔离web层,在这种情况下你测试web层只需要通过<code>DispatcherServlet</code>但是实际上你是使用了Spring配置信息的,就像你可以隔离掉数据访问层之上的层面来测试数据访问层一样.当然,你也可以使用单独的配置,每次只关注一个controller并且手动提供使其运行所必须的配置文件.</p>
<p>使用Spring MVC的另一个重大的区别是,从概念上讲,这些测试是服务端的,所以你可以检查哪个Handler被使用了,如果一个异常被HandlerExceptionResolver处理了,这时候模型的内容是什么,绑定的是什么错误和其他的信息(可以很轻松的获取).这也就意味着写expectations会变得简单,因为server这时候就不是一个黑盒了,就像是通过实际的HTTP客户端去测试一样.传统的单元测试的优势是:易于编写,推理和调试但是不能完全取代完整的集成测试.同时,重要的是不要忽略了最重要的是要去检查response这件事.简而言之,即使在一个项目中,也存在多种的测试的风格和策略(条条大路通罗马).</p>
<h3 id="Further-Server-Side-Test-Examples"><a href="#Further-Server-Side-Test-Examples" class="headerlink" title="Further Server-Side Test Examples"></a>Further Server-Side Test Examples</h3><p>这个框架自己的测试包含了<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples">很多测试的例子</a>为了展示如何使用Spring MVC Test.你可以打开这些例子来寻找更多的灵感.同时,<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-mvc-showcase"><code>spring-mvc-showcase</code></a>项目覆盖了完整的基于Spring MVC Test的测试.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://misakatang.cn/2018/10/14/%E8%B7%9F%E7%9D%80qsc%E6%90%9E%E6%9C%BA-%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%BB%8E%E8%B5%8C%E5%8D%9A%E6%9C%BA%E5%88%B0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/misaka.jpg">
      <meta itemprop="name" content="MisakaTang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MisakaTang's Blog">
      <meta itemprop="description" content="The limits of my language are the limits of my world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | MisakaTang's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/14/%E8%B7%9F%E7%9D%80qsc%E6%90%9E%E6%9C%BA-%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%BB%8E%E8%B5%8C%E5%8D%9A%E6%9C%BA%E5%88%B0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">跟着qsc搞机(器学习)--从赌博机到推荐系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-14 22:06:04" itemprop="dateCreated datePublished" datetime="2018-10-14T22:06:04+00:00">2018-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-14 08:33:24" itemprop="dateModified" datetime="2024-03-14T08:33:24+00:00">2024-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在度过了今年的最爽假期也是最后假期之后的星期六,又看到了qsc更新视频的我是很欣喜的,但是看完之后的我是懵逼的:怎么难度一下从天堂到了地狱~~,当然了,最后卿学姐也说了,这是一个导论性质的介绍,那么就让我再总结一下吧.</p>
<p>先放上视频的地址:<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av33638179">机器学习算法讲堂(4):Explore and exploit算法 LinUcb《Bandits in Recommendation》</a></p>
<h1 id="从老虎机开始"><a href="#从老虎机开始" class="headerlink" title="从老虎机开始"></a>从老虎机开始</h1><p>让我们来想象这样一个情景:</p>
<blockquote>
<p>一个赌徒，要去摇老虎机，走进赌场一看，一排老虎机，外表一模一样，但是每个老虎机吐钱的概率可不一样，他不知道每个老虎机吐钱的概率分布是什么，那么每次该选择哪个老虎机可以做到最大化收益呢？</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/4155986-85269ad91ee8ce57?imageMogr2/auto-orient/strip%7CimageView2/2/w/314"></p>
<p>这就是多臂赌博机问题(Multi-armed bandit problem, K-armed bandit problem, MAB),也就是我们需要<strong>在有限的回合内找出一个系统的最大收益</strong>,而之所以用MAB问题来举例的原因也是因为,这个问题的抽象可以套在很多推荐系统的问题之上,例如:</p>
<ul>
<li>假设一个用户对不同类别的内容感兴趣程度不同，那么我们的推荐系统初次见到这个用户时，怎么快速地知道他对每类内容的感兴趣程度？</li>
<li>假设我们有若干广告库存，怎么知道该给每个用户展示哪个广告，从而获得最大的点击收益？是每次都挑效果最好那个么？那么新广告如何才有出头之日？</li>
<li>….</li>
</ul>
<p>可以发现,这些问题都跟老虎机是一样的:我们需要在有限的回合内找到老虎机的最大收益&#x3D;&#x3D;&gt;我们需要在有限次数内找到推荐广告的最大收益</p>
<p>而在推荐系统领域对于这类问题有一个统一的说法,叫做<strong>Explore-Exploit问题</strong>,也就是如何来最大化探索和利用的价值的问题,比如:</p>
<blockquote>
<ul>
<li>Explore(探索):我们需要探索用户的兴趣点而且需要不断地探索新的兴趣来保证用户对系统的新鲜度,这是一个长期的,挖掘潜在价值的,成长型的需求</li>
<li>Exploit(利用):当我们探索出最大价值的时候我们需要利用,这是一个贪婪的,短期的,需要奖励来反馈激励的需求</li>
</ul>
</blockquote>
<p>就像是在玩老虎机:我们发现一个老虎机吐钱很多,那肯定需要用它来赚钱啊,但是我们也不能保证它就是最赚钱的,我们也得去探索其他的老虎机的赚钱能力,而如何来协调探索和利用的关系来使得我们的系统产生出最大的价值,也就是需要研究的地方了.</p>
<h1 id="Bandits-in-Recommendation"><a href="#Bandits-in-Recommendation" class="headerlink" title="Bandits in Recommendation"></a>Bandits in Recommendation</h1><h2 id="知识准备-累积遗憾"><a href="#知识准备-累积遗憾" class="headerlink" title="知识准备-累积遗憾"></a>知识准备-累积遗憾</h2><p>当然这一点在qsc的视频中没有着重讲,但是在看其他博客的时候还是觉得需要补充一下.</p>
<p><strong>累积遗憾</strong>也就是Bandits算法中用来量化一个策略好坏的指标,用公式写出来是这样的:<br>$$<br>R_A(T) &#x3D; E\left[\sum_{t&#x3D;1}^Tr_t,a_t^*\right]-E\left[\sum_{t&#x3D;1}^Tr_t,a_t\right]<br>$$</p>
<p>这里t表示轮数,r表示回报.公式右边的第一项表示第t轮的期望最大收益，而右边的第二项表示当前选择的arm获取的收益，把每次差距累加起来就是总的遗憾.显然的,累积遗憾越小,算法的效果也就越好.</p>
<h2 id="epsilon-greedy-algorithm-贪心策略"><a href="#epsilon-greedy-algorithm-贪心策略" class="headerlink" title="$\epsilon$-greedy algorithm(贪心策略)"></a>$\epsilon$-greedy algorithm(贪心策略)</h2><p>我们来看一种最简单的贪心的策略,方法如下:<br>在每一步:</p>
<ul>
<li>使用一个我们选择的概率$\epsilon$,随机的选择一个手臂去摇老虎机(探索)</li>
<li>其他的(1-$\epsilon$)概率下,我们选择当前最赚钱的老虎机摇一下(利用)</li>
</ul>
<p>然后我们观察最后的回报来调整概率达到最优解,然而这个算法的问题在于:我们的选择是随机的,但是实际上,我们在摇了很多下老虎机之后是知道哪些比较赚钱那些不怎么赚钱,而这个信息没有被利用起来.我们的改进思路也就变成了从随机选择去寻找更加<strong>聪明</strong>的选择方法.</p>
<h2 id="Thompson-sampling"><a href="#Thompson-sampling" class="headerlink" title="Thompson sampling"></a>Thompson sampling</h2><h3 id="Beta-Distribution-Beta分布"><a href="#Beta-Distribution-Beta分布" class="headerlink" title="Beta Distribution(Beta分布)"></a>Beta Distribution(Beta分布)</h3><p>关于beta分布几乎是没有了解的,但是在这只需要知道它是一种概率分布就可以了,这里先给出分布的公式:<br>$$<br>f(x;\alpha,\beta) &#x3D; constant \cdot x^{\alpha-1}(1-x)^{\beta-1}&#x3D;\frac {1} {B(\alpha,\beta)} x^{\alpha-1}(1-x)^{\beta-1}<br>$$</p>
<p>这里我们需要关注的是beta分布的方差的计算(实验的次数越少方差就越大):<br>$$<br>var(X)&#x3D;E[(X-\mu)^2]&#x3D;\frac {\alpha\beta} {(\alpha+\beta)^2(\alpha+\beta+1)}<br>$$</p>
<h3 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h3><p>而这个方差的特征正是我们所希望的,比如我们摇了一个老虎机10000次,它赚的钱是500块而另一个老虎机我们只摇了100次赚的钱是5块,如果我们在这两个老虎机之间做抉择的话,肯定会选择后一个,因为它的<strong>上限比前者高</strong>,因为前者我们几乎以及可以肯定它就是10000次赚500,而后者可能比它<strong>更赚钱</strong>,虽然现在来看它们的平均收益是一样的.下面是ppt中对beta分布的可视化:<br><img src="https://i.loli.net/2018/10/14/5bc35c093ae4c.png"></p>
<p>item-b和item-c就是上面的摇了10000次的老虎机和摇了100次的老虎机.<br>而Thompson sampling算法的思路就和上面的想法一样,假设每个老虎机的吐钱概率符合beta分布,跟随机选择手臂的贪心算法比起来,优化的地方就在于:<strong>用每个手臂的beta分布生成一个随机数,选择这些随机数中最大的那个手臂摇一下</strong>.下面给出贪心算法和Thompson sampling算法伪代码的比较:<br><img src="https://i.loli.net/2018/10/14/5bc35e6498f49.png"></p>
<h2 id="UCB-Upper-Confidence-Bound-置信区间上界"><a href="#UCB-Upper-Confidence-Bound-置信区间上界" class="headerlink" title="UCB:Upper Confidence Bound(置信区间上界)"></a>UCB:Upper Confidence Bound(置信区间上界)</h2><p>在之前我们也提到了,贪心算法的缺点就在于没有利用前面已经摇了的老虎机的信息,上面的Thompson sampling算法给出了一种利用的思路,而UCB(置信区间上界)则是另一种利用的方式.<br>大致的思路是:我们假设每一个老虎机的吐钱概率<br>$$<br>Q(a)\leq \hat{Q_t}(a)+\hat{U_t}(a)<br>$$<br>这里的$\hat{Q_t}(a)$就是每个老虎的收益的均值,而$\hat{U_t}(a)$可以认为是<strong>这个老虎机的赚钱潜力</strong>,而这个潜力也能够使得很少被摇到的但是很赚钱的老虎机被发掘出来.那么现在的问题就是要对$\hat{U_t}(a)$来确定一个上界,也就是它的极限赚钱能力是多少,而这个上界在1963年被Hoeffding找到了并且命名为<strong>Hoeffding Inequality</strong>,其中的上界的解是:<br>$$<br>\hat{U_t}(a) &#x3D; \sqrt{\frac {-\log p} {2N_t(a)}}<br>$$<br>其中的p是我们假设的概率,$N_t(a)$则是实验的次数</p>
<h3 id="Bayesian-UCB"><a href="#Bayesian-UCB" class="headerlink" title="Bayesian UCB"></a>Bayesian UCB</h3><p>虽然我们已经可以通过上面的公式来计算每个老虎机的置信区间上界从而选择摇那个老虎机,但是缺陷是这个上界太大了,也就是说实际的效果并不会很好,而其中的一个解决方案就是假设$Q(a)$服从贝叶斯分布,这样我们就可以直接根据公式来算出上界,至于效果的话,直接引用paper中的一个比较,可以看到优化的效果是比较好的.<br><img src="https://i.loli.net/2018/10/14/5bc365a414eab.png"></p>
<p>这是上面提到的几种算法的效果的比较图:<br><img src="https://i.loli.net/2018/10/14/5bc366846fe44.png"></p>
<h2 id="LinUCB–UCB算法的一次进化"><a href="#LinUCB–UCB算法的一次进化" class="headerlink" title="LinUCB–UCB算法的一次进化"></a>LinUCB–UCB算法的一次进化</h2><p>算法的优化还在继续,上面的UCB算法的最大问题在于它是context-free(上下文无关)的,这怎么行呢(滑稽),所以我们的算法优化的下一步就是<strong>给UCB算法插上特征的翅膀</strong>.也就是我们给每一个手臂都加上一个上下文的特征,当然这里再举老虎机似乎不是很贴切了,可以把手臂变成替用户挑选商品的手臂.那么与此对应的,我们给每个手臂能够获得的期望收益一个定义:<br>$$<br>E[r_{t,a}|x_{t,a}] &#x3D; x_{t,a}^\top \bf {\theta}_{a\cdot}^*<br>$$<br>假设手机到了m次反馈，特征向量可以写作Da(维度为md)，假设我们收到的反馈为Ca(维度为m1)，那么通过求解下面的loss，我们可以得到当前每个手臂的参数的最优解：<br>$$<br>loss &#x3D; (C_a-D_a\theta_a)^2+\lambda\begin{Vmatrix} \theta_a \end{Vmatrix}<br>$$<br>然后我们可以使用ridge-regression(岭回归)得到explicit solution(闭式解):<br>$$<br>\theta_a &#x3D; (D_a^TD_a+I)^-1D_a^Tc_a<br>$$<br>而根据UCB方法,我们除了需要一个均值之外,还需要找到一个置信上界,而这个置信上界也被人找出来了.反正最后我们需要训练的函数就可以确定下来,就是下面这一坨了(实在不行了,mathjax真难写):<br><img src="https://i.loli.net/2018/10/15/5bc36ecf0b556.jpg"></p>
<p>给出LinUCB算法的伪代码:<br><img src="https://i.loli.net/2018/10/15/5bc36f1424dba.png"></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>是上下文相关的</li>
<li>上下文特征的回报函数是线性的</li>
<li>是一个岭回归&#x3D;&#x3D;&gt;是有解析解的</li>
<li>服从高斯分布&#x3D;&#x3D;&gt;有UCB上界</li>
<li>是一个在线的算法(个人认为是:有新的数据进来不需要重新训练模型)</li>
</ul>
<h2 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h2><p>下面就是一些比较简短的优化的方向了</p>
<ul>
<li>CoLin:协同过滤,引入了用户之间的关系(这个还是挺重要的特征)</li>
<li>hLinUCB:加入了hidden-feature(隐向量)</li>
<li>FactorUCB&#x3D;hLinUCB+CoLin</li>
</ul>
<p>最后的最后,放上一个Bandit算法的进化路径的图吧:<br><img src="https://i.loli.net/2018/10/15/5bc370aa65673.png"><br>可以看到进化的方向就是从随机选择到更加聪明的选择,从上下文无关到上下文相关,也是越来越能够贴近推荐系统的核心需求了.</p>
<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21388070">专治选择困难症——bandit算法</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21404922">UCB算法升职记——LinUCB算法</a><br><a target="_blank" rel="noopener" href="https://juejin.im/entry/5b2732b3e51d4558a14b426a">推荐系统遇上深度学习(十三)–linUCB方法浅析及实现</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiangjiang_jian/article/details/80674506">推荐系统遇上深度学习(十二)–推荐系统中的EE问题及基本Bandit算法</a></p>
<h1 id="论文引用"><a href="#论文引用" class="headerlink" title="论文引用"></a>论文引用</h1><p><a target="_blank" rel="noopener" href="http://rob.schapire.net/papers/www10.pdf">LinUCB</a><br><a target="_blank" rel="noopener" href="http://www.cs.virginia.edu/~hw5x/Course/Old-CS6501-Text-Mining-2016-Spring/docs/Projects/CoLinUCB_qw2ky.pdf">CoLinUCB</a><br><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1401.8257.pdf">CLUB</a><br><a target="_blank" rel="noopener" href="http://www.cs.virginia.edu/~hw5x/paper/lfp1145-Wang.pdf">hLinUCB</a><br><a target="_blank" rel="noopener" href="http://www.cs.virginia.edu/~hw5x/paper/factorUCB.pdf">FactorUCB</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为是一个导论性质的小讲堂所有内容还是有点多的,消化起来也有点慢也有点吃力,但是还是很开拓眼界的.</p>
<blockquote>
<p>吾尝终日而思矣,不如须臾之所学也</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://misakatang.cn/2018/10/13/%E4%B8%89%E6%9C%88%E7%9A%84%E7%8B%AE%E5%AD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/misaka.jpg">
      <meta itemprop="name" content="MisakaTang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MisakaTang's Blog">
      <meta itemprop="description" content="The limits of my language are the limits of my world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | MisakaTang's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/13/%E4%B8%89%E6%9C%88%E7%9A%84%E7%8B%AE%E5%AD%90/" class="post-title-link" itemprop="url">三月的狮子</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-13 20:54:10" itemprop="dateCreated datePublished" datetime="2018-10-13T20:54:10+00:00">2018-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-14 08:33:24" itemprop="dateModified" datetime="2024-03-14T08:33:24+00:00">2024-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/%E5%88%86%E7%B1%BB/%E7%94%9F%E6%B4%BB/" itemprop="url" rel="index"><span itemprop="name">生活</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2018/10/13/5bc2043ab3ec7.jpg"></p>
<hr>
<blockquote>
<p>March comes in like a lion, and goes out like a lamb</p>
</blockquote>
<hr>
<p>国庆长假时突感无聊就找了一个补番推荐,然后就打开了这部番,谁知一看就不可收拾,一口气就看完了两季44集,以及很久没有这种感觉了,每一集都看的很舒服而且停不下来,上一次这么完整的看一部番剧应该是看钢炼的时候了吧.回到这部番,虽然讲的是主角下将棋的故事,一开始我是这么认为的,但是随着故事的发展才发现,将棋只是一部分,最重要的还是主角的成长和其他人的故事.</p>
<p>可以说零是不幸的,因为他自幼失去双亲和妹妹,虽然被父亲的朋友收养但是在新家里不受”姐姐”和”弟弟”的尊敬,最终害怕养父和子女的关系继续恶化而自己搬出来住,在学校中也因为研究将棋而没有同龄玩伴而被孤立.但是也可以说零是幸运的,而且比大多数人都幸运,因为有川本这样一个耀眼的”家”和川本三姐妹,二海堂这样的好友和林田这样关心学生的班主任.但这也就是人生吧,苦难和快乐总是交织的,而只有经历了深沉的苦难的人,才能更好的把握那仅有的幸福.</p>
<p>虽然很多人都说这部番节奏太慢了,但是我觉得就这样,就很好,像流水一样慢慢地慢慢地将每一个人的故事都讲了出来,这也是我觉得这部番好的一个原因,每一个人物都塑造的很成功,有为了不辜负乡亲们的期待而慢慢变强的岛田师兄,有因为身体原因而想在将棋上和别人公平对决的二海堂,有被挚友们托付了将棋愿望而66岁还坚守在A级的柳原棋匠,有二十多年容颜不变但患了听觉障碍的棋鬼宗谷名人,等等等等…每一个故事,每一个人都在为了生活而奋斗,这样不是就很好吗</p>
<p>这部番让我感到喜欢的还有画风,虽然一开始有点接受不能,但是在习惯之后,这种鲜明的用画面来表达情绪的画风反而变得很好,并且作画很跳跃,到最后甚至很喜欢这种画风,快乐时一切都是花样的,悲伤时又是如此的萧条和黑暗,而那无时不在的写成文字并讲出来的声音,也令人印象深刻.</p>
<p>零从一开始的”没有拼搏的理由”,到最后开始全力以赴,生活也从孤零零的阴暗的房间变成了多彩的世界,生活不易,每个人都在用自己的方式和生活斗争着,就算是零,从小就独自一人,在故事的最后,身边也有这么多人在相互扶持,我觉得这就是这部番给我最大的温暖吧.</p>
<p>给我印象很深的是在<em>chapter 21</em>中零的独白:</p>
<blockquote>
<p>难道都是我的错吗？！<br>那么你告诉我该怎么办啊？！<br>开什么玩笑！<br>你弱你有理吗？！<br>因为弱才会输啊！<br>拜托你去学习啊！<br>我知道你在偷懒啊！<br>不要说什么，道理我懂，但我做不到，之类的话啊！<br>既然这样，那干脆别来啊！<br>我可是赌上了全部啊！<br>除了将棋，我一无所有啊！<br>不要借酒来逃避现实啊！<br>我对弱者没兴趣啊！  </p>
</blockquote>
<p>是啊,这个故事不仅是讲给零听的啊,而当零被岛田拍醒的那一刹那,我知道也知道了:</p>
<blockquote>
<p>虽然嘴上说没有战斗的理由，但我知道自己体内住着一头野兽，就算把周围东西咬碎也要只为生存而奔走的野兽<br>不论让谁变得不幸，无论世界变成什么样子</p>
</blockquote>
<p>可能也就是三月的狮子这个名字的由来吧:青春如同狮子一般咆哮着降临，最也难免以柔和的方式度过余生.</p>
<p>这个故事是讲的如此之好,没有煽情也没有夸大,而是把故事摆在你面前,无论是快乐还是伤心,无论是光明还是黑暗,都是如此的直击人性,令人难以忘怀,而在这个故事仍没有结束的夜晚,在我心中也流淌着一丝的温暖.</p>
<p>最后放一首ED,是米津玄師的orion.</p>
<blockquote>
<p>あなたの指が その胸が その瞳が<br>眩しくて少し 眩暈がする夜もある<br>それは不意に落ちてきて<br>あまりにも暖かくて<br>飲み込んだ七色の星<br>弾ける火花みたいに<br>ぎゅっと僕を困らせた<br>それでまだ歩いてゆけること<br>教わったんだ<br>神様どうかどうか<br>声を聞かせて<br>ほんのちょっとでいいから<br>もう二度と離れないように<br>あなたと二人あの星座のように<br>結んで欲しくて<br>夢の中でさえどうも<br>上手じゃない心具合<br>気にしないでって嘆いたこと<br>泣いていたこと<br>解れた袖の糸を引っぱって<br>ふっと星座を作ってみたんだ<br>お互いの指を星として<br>それは酷くでたらめで<br>僕ら笑いあえたんだ<br>そこにあなたがいてくれたなら<br>それでいいんだ<br>今ならどんなどんな<br>困難でさえも<br>愛して見せられるのに<br>あんまりに柔くも澄んだ<br>夜明けの間ただ眼を見ていた<br>淡い色の瞳だ<br>真白でいる陶器みたいな<br>声をしていた冬の匂いだ<br>心の中静かに荒む<br>嵐を飼う闇の途中で<br>落ちてきたんだ僕の頭上に<br>煌めく星泣きそうなくらいに<br>触れていたんだ<br>神様どうかどうか<br>声を聞かせて<br>ほんのちょっとでいいから<br>もう二度と離れないように<br>あなたと二人この星座のように<br>結んで欲しくて<br>結んで欲しくて  </p>
</blockquote>
<blockquote>
<p>你的手指 你的胸口 还有你的眼眸<br>如此的闪耀 在这夜里让人眩晕<br>不经意间落下的<br>如此温暖的<br>将我吞噬的七色之星<br>宛如四射的火花<br>让我无比困扰<br>不过我也因此受益匪浅<br>明白了我还能继续前进<br>神啊 怎么办啊 怎么办啊<br>让我听到你的声音<br>哪怕只有一瞬也没关系<br>为了让我们再也不分开<br>希望你我二人 就像那互相连接的星座<br>永生相随<br>就算是在梦中的世界<br>好像还是会屡屡受挫<br>叹着气说不要在意<br>眼泪也落了下来<br>将袖口脱落的线<br>试着做成一个星座<br>将你我的指尖当做星星<br>这样太过离谱<br>我们看着对方笑了起来<br>其实只要你一直在那里的话<br>我就很心满意足了<br>现在<br>不论有多大的困难在眼前<br>为了你我都会甘之如饴<br>可这黎明实在是 过于柔和澄澈<br>所以我只能 一直望着你的眼眸<br>那双有着淡淡色彩的眼眸<br>犹如陶器一般 纯白无暇<br>就像围绕在耳边的 冬天的气息<br>在心中 静静肆虐的暴风雨<br>在那漆黑一片的途中<br>降临在我的头顶<br>无数明暗闪烁的星 如今就近在指尖<br>让我有想哭的冲动<br>神啊 怎么办啊 怎么办啊<br>让我听到你的声音<br>哪怕只有一瞬也没关系<br>为了让我们 再也不分开<br>希望你我两人 就像那互相连接的星座<br>永生相随<br>永生相随  </p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/20/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/22/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">MisakaTang</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/TangMisaka23001" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","mhchem":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
